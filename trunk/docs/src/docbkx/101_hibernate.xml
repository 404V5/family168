<?xml version="1.0" encoding="UTF-8"?>
<chapter xml:id="hibernate">
    <title>Hibernate</title>

    <para>感觉是目前最成熟的ORM框架，家族中新添了hibernate-shards支持多数据库访问，hibernate-search提供全文检索，大有潜力可挖。</para>
    <sect1>
        <title>基于annotation的JPA式配置</title>
        <para>在spring中配置：</para>
        <programlisting><![CDATA[
sessionFactory的类型改为org.springframework.orm.hibernate3.annotation.AnnotationSessionFactoryBean]]>
        </programlisting>
        <para>使用spring-2.5.6中新加的packagesToScan对整个目录下的类进行扫描，这样就不用在annotatedClasses中写一长串类名了。</para>
        <programlisting><![CDATA[
<property name="packagesToScan">
    <list>
        <value>com.family168.domain</value>
    </list>
</property>]]>
        </programlisting>
        <para>对于jbpm这种使用xml映射的工程，还需要配置mappingLocations。</para>
        <programlisting><![CDATA[
<property name="mappingLocations">
    <value>classpath*:/org/jbpm/**/*.hbm.xml</value>
</property>]]>
        </programlisting>
        <programlisting><![CDATA[package com.family168.domain;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;


@Entity
public class User {
    private Long id;
    private String name;

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    @Column
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}]]>
        </programlisting>
        <tip>如果pojo要定义getter方法，这个方法数据库的持久字段没有关联，必须使用@Transient标注，否则hibernate会把它当作一个持久字段，去数据库读取的时候会报错。</tip>
    </sect1>

    <sect1>
        <title>Hibernate支持的关系模型</title>
        <itemizedlist>
            <listitem>
                <para>一对多，使用外键进行表间关联</para>
                <para>见com.family168.domain.Parent和com.family168.domain.Child</para>
            </listitem>
            <listitem>
                <para>一对一，使用外键进行表间关联（在子表使用主键与外键结合的方式不够灵活）</para>
                <para>我们使用的方法是在外键上加唯一约束，见com.family168.domain.Father和com.family168.domain.Mother</para>
            </listitem>
            <listitem>
                <para>多对多，使用连接表进行表间关联</para>
                <para>见com.family168.domain.Role和com.family168.domain.Resc</para>
            </listitem>
            <listitem>
                <para>继承，包括一表多类，每表一类，一主表多字表等形式</para>
                <para>尚未用到。之前用过一次，一表多类，不知如何直接取得子类数据。</para>
            </listitem>
        </itemizedlist>
    </sect1>

    <sect1>
        <title>Hibernate应用备注</title>
        <para>在使用Hibernate时，需要注意的一些方面。</para>
        <sect2>
            <title>Open Session In View</title>
            <para>加一个Spring带的Filter是最简单通用的方法</para>
            <programlisting><![CDATA[
<filter>
    <filter-name>hibernateFilter</filter-name>
    <filter-class>org.springframework.orm.hibernate3.support.OpenSessionInViewFilter</filter-class>
</filter>]]>
            </programlisting>
            <programlisting><![CDATA[
<filter-mapping>
    <filter-name>hibernateFilter</filter-name>
    <url-pattern>*.do</url-pattern>
</filter-mapping>]]>
            </programlisting>
        </sect2>
        <sect2>
            <title>Event Listener</title>
            <para>参考com.family168History.EventListener, 在对象的update,delete,post-update等事件中加入AOP特性.</para>
            <para>它类似于数据库中的trigger，可以拦截到对象的生命周期事件，而且能拿到诸如update前后的数据，传统的方式需要以方法执行前后为Point Cut使用AOP拦截，而数据库trigger则需要每个表写一次trigger，难于管理，达不到Event Listener批量处理的效果。</para>
            <para>Event Listener在批量处理时，一般设计让处理方法相同的POJO实现同一个接口，然后就可以在Event Listener里就以if(pojo instance of MyEventInterface)来区分处理。</para>
        </sect2>
        <sect2>
            <title>查询返回Map</title>
            <programlisting><![CDATA[
String hql = "select new map(goods.goodsNo as goodsNo,goods.code as code) from Goods goods";
// 即可以用Map进行访问
Map goods = (Map) list.get(0);
String code = (String) goods.get("code");]]>
            </programlisting>
            <para>这样可以避免一些N+1的问题，对比直接用result[0],result[1]访问的恐怖写法，或者定义一个新pojo的繁琐，返回map比较折衷。</para>
        </sect2>
        <sect2>
            <title>限制修改</title>
            <para>设置@Column(updatable = false)，则该属性插入数据库后不可修改。这个字段不会出现在update语句中。</para>
            <para>返回Collection时设置unmodifiable，如：</para>
            <programlisting><![CDATA[
public Set<Category> getCategories() {
    return Collections.unmodifiableSet(categories);
}]]>
            </programlisting>
        </sect2>
    </sect1>

    <sect1>
        <title>二级缓存</title>
        <para>hibernate的session提供了一级缓存，在同一个session中对同一个id的对象load两次，并不会发送两条sql给数据库。session关闭的时候，一级缓存就失效了。如果希望跨session使用缓存，就需要为hibernate配置二级缓存。</para>
        <para>二级缓存是SessionFactory级别的全局缓存，它支持不同的缓存类库，比如ehcache、oscache等，使用时需要配置对应的缓存实现方案。</para>
        <sect2>
            <title>基本设置</title>
            <para>把一个ehcache.xml文件拷贝到classpath下，在hibernate.properties加上</para>
            <programlisting><![CDATA[
hibernate.cache.use_query_cache=true
hibernate.cache.provider_class=org.hibernate.cache.EhCacheProvider]]>
            </programlisting>
            <para><![CDATA[applicationContext.xml的<property name="hibernateProperties">下加上]]></para>
            <programlisting><![CDATA[
<prop key="hibernate.cache.use_query_cache">${hibernate.cache.use_query_cache}</prop>
<prop key="hibernate.cache.provider_class">${hibernate.cache.provider_class}</prop>]]>
            </programlisting>
            <note>
                <para>如果不想把ehcache.xml直接放在classpath下，可以使用hibernate.cache.provider_configuration_file_resource_path配置ehcache.xml所在的路径，比如/cache/ehcache.xml，这里我们把ehcahce.xml放在classpath下的cache目录下。</para>
                <para>ehcache提供了一个共享CacheManager的方法，我们每次可以调用CacheManager的create()方法获得单例，而不需要每次new一个新的CacheManager实例，在spring中，可以为org.springframework.cache.ehcache.EhCacheManagerFactoryBean配置shared=true来启用这个功能。而在hibernate的svn中可以看到一个org.hibernate.cache.SingletonEhCacheProvider，它里面也是使用create()来获得单例的，可惜在现在发布的3.3.1.GA中还没有包含这个类。</para>
            </note>
        </sect2>
        <sect2>
            <title>Entity级二级缓存</title>
            <para>Entity二级缓存是把PO放进cache，用PO的id作为key，用PO的实例作为value进行缓存。</para>
            <para>因为还没有经过详细的测试，我们现在唯一确认的只有load()方法是肯定可以利用Entity级缓存的，在对级联数据延迟加载的时候也可以利用二级缓存，不知道get()方法是否也可以利用到Entity缓存的，希望可以，这样就可以省去我们很多很多的麻烦了。</para>
            <para>在POJO中添加缓存的注解：</para>
            <programlisting><![CDATA[
@Entity
@Table(name = "MENU")
@Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)
public class Menu extends LongTreeNode<Menu> {]]>
            </programlisting>
            <para>如果你使用的二级缓存实现是ehcache的话，需要配置ehcache.xml，否则ehcache会使用默认的配置</para>
            <programlisting><![CDATA[
<cache name="com.family168.domain.Category"
    maxElementsInMemory="500"
    eternal="false"
    timeToLiveSeconds="7200"
    timeToIdleSeconds="3600"
    overflowToDisk="true" />]]>
            </programlisting>
        </sect2>
        <sect2>
            <title>Collection二级缓存</title>
            <para>光为Entity配置了二级缓存还不够，对于一对一，一对多，多对多这类的级联对象，还需要配置Collection缓存。用法就是在Collection属性部分添加Cache注解。</para>
            <programlisting><![CDATA[
/** * @return children. */
@OneToMany(cascade = CascadeType.ALL, fetch = FetchType.LAZY, mappedBy = "parent")
@OrderBy("theSort asc, id desc")
@Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)
public Set<Menu> getChildren() {
    return children;
}]]>
            </programlisting>
            <para>还要在ehcache.xml中添加对应的配置</para>
            <programlisting><![CDATA[
<cache name="com.family168.leona.security.domain.Menu.children"
    maxElementsInMemory="1000"
    eternal="false"
    timeToLiveSeconds="7200"
    timeToIdleSeconds="3600"
    overflowToDisk="true" />]]>
            </programlisting>
            <para>注意cache的name，是由全类名加上Collection的属性名组成的。</para>
        </sect2>
        <sect2>
            <title>查询缓存</title>
            <para>上面的二级缓存是针对单个对象的，如果要对查询结果，则是用下面的语句</para>
            <programlisting><![CDATA[
query.setCacheable(true);//激活查询缓存
query.setCacheRegion("categoryCacheRegion");//指定要使用的cacheRegion，可选]]>
            </programlisting>
            <para>cacheRegion是可选的，可以对使用的缓存进行特殊设置， 在ehcahe.xml里要补上下面的一段。</para>
            <programlisting><![CDATA[
<cache name="categoryCacheRegion"
    maxElementsInMemory="10"
    eternal="false"
    timeToIdleSeconds="3600"
    timeToLiveSeconds="7200"
    overflowToDisk="true" />]]>
            </programlisting>
            <para>对于Query二级缓存，它是使用hql和参数等为key，List为value实现缓存，暂时还不确定它里面的对象与Entity和Collection中缓存的对象是否能自动保证同步，还有一种说法是在查询的第一次使用List，把数据都搜索出来，以后再使用Iterator利用二级缓存进行操作。不知道这里说的Iterator利用的是Query二级缓存还是Entity二级缓存。</para>
        </sect2>
        <para>看完了hibernate中的三类二级缓存，在网上搜到很多类似的帖子，感觉从2004年到现在的5年时间里，对hibernate缓存的研究不但没有深入化，反而愈见平淡，似乎没有人在项目中实际使用过cache一样的感觉，最多见到的就是Entity缓存，不过我对这些缓存的更新策略还有所怀疑，究竟是否能够保证实时更新，是否有需要周期手工维护缓存的必要，再加上2004年java上有人提出的问题，这三类缓存之中的对象是否是否能保证同步等等。最后也没办法了解到read_only, nonstrict_read_write, read_write和transactional这四类缓存之间的决定性差别，介于ehcache只支持前三种缓存，估计在实际使用中就先选择read_write这一级别了。</para>
        <para>最后放上一个log的配置，可以查看缓存是否命中的日志信息。如果命中了，就会打印出hit来。</para>
        <programlisting><![CDATA[
<logger name="net.sf.ehcache" level="debug">
    <appender-ref ref="FILE"/>
</logger>
<logger name="org.hibernate.cache" level="debug">
    <appender-ref ref="FILE"/>
</logger>]]>
        </programlisting>
    </sect1>

    <sect1>
        <title>对Hibernate进行封装</title>
        <para>对Hibernate进行封装，使用泛型让manager只需要继承超类就可以实现所有的基本功能。</para>
        <programlisting><![CDATA[
public class UserManager extends HibernateEntityDao<User>]]>
        </programlisting>
        <sect2>
            <title>基本方法</title>
            <itemizedlist>
                <listitem>
                    <para>public Object get(Serializable id)</para>
                </listitem>
                <listitem>
                    <para>public List getAll()</para>
                </listitem>
                <listitem>
                    <para>public void save(Object o)</para>
                </listitem>
                <listitem>
                    <para>public void removeById(Serializable id)</para>
                </listitem>
                <listitem>
                    <para>public void remove(Object o)</para>
                </listitem>
                <listitem>
                    <para>public List find(String hql, Object... values)</para>
                </listitem>
                <listitem>
                    <para>public Object findBy(String name,Object value)</para>
                </listitem>
                <listitem>
                    <para>public List findByLike(String name, Object value)</para>
                </listitem>
                <listitem>
                    <para>public T findUnique(String hql, Object... values)</para>
                </listitem>
                <listitem>
                    <para>public T findUniqueBy(String name, Object value)</para>
                </listitem>
            </itemizedlist>
        </sect2>
        <sect2>
            <title>分页方法</title>
            <para>提供Criteria和HQL两种方式的分页方法</para>
            <itemizedlist>
                <listitem>
                    <para>public Page pagedQuery(Criteria c, int pageNo, int pageNo)</para>
                </listitem>
                <listitem>
                    <para>public Page pagedQuery(String hql, int pageNo, int pageNo, Object... params)</para>
                </listitem>
            </itemizedlist>
            <tip><para>需要注意的是，这里提供的分页方法会直接去掉select，order by等子句，会造成在子句对查询结果起作用的时候出现问题，据说出现having子句的时候就有这个问题。听说bba96可以解决这个问题。</para></tip>
            <para>需要提一下：bba96，这是由国人开发的封装hibernate的组件，据闻提供了强力功能，但是源代码一无注释，二无单元测试，让人无从下手。</para>
        </sect2>
        <sect2>
            <title>对Hibernate做了三层封装</title>
            <orderedlist>
                <listitem>
                    <para>第一层：HibernateGenericDao，基于spring的HibernateDaoSupport，但加入了分页函数与各种Finder函数，并使用泛型避免了返回值强制类型转换。</para>
                </listitem>
                <listitem>
                    <para>第二层：HibernateEntityDao，基于HibernateGenericDao，用泛型声明Dao所管理的Entity类，默认拥有该entity的CRUD方法。</para>
                </listitem>
                <listitem>
                    <para>第三层：HibernateExtendDao，基于HibernateEntityDao，主要扩展各种选择性的功能。</para>
                </listitem>
            </orderedlist>
            <sect3>
                <title>HibernateGenericDao</title>
                <para>在Spring HibernateDaoSupport基础上封装的DAO，功能如下：</para>
                <orderedlist>
                    <listitem>
                        <para>应用泛型:使得find(), get() 这些函数不再返回Object，而是返回T，不再需要强制类型转换。</para>
                    </listitem>
                    <listitem>
                        <para>提供各种finder的简便函数</para>
                        <para>应用了JDK5可变参数的hsql查询函数：List find(String hql, Object... values)，支持find(hql),find(hql, param1); find(hql,param1,param2);find(hql,new Object[] {param1,param2}) 四种接口。 </para>
                        <para>简单查询的简化函数：findBy(Class entityClass,String name,Object value) ,findUniqueBy(Class entityClass,String name, Object value),findByLike(Class entityClass,String name,Object value) </para>
                    </listitem>
                    <listitem>
                        <para><![CDATA[获得设置好的Query和Criteria：createQuery(String hql,Object... values)  和 createCriteria(Class<T> entityClass,Criterion... criterions)]]></para>
                        <para>Spring并没有很好的接口封装支持firstResult, maxResult, fetchsize,cache,cacheRegion 等多个查询参数，所以springside宁愿返回已设置好查询条件的Query和Criteria，让大家继续剩下的参数设置，最后再执行list()，注意那几个参数可以连续设置的，如：</para>
                        <programlisting><![CDATA[
createQuery(hql,param1).setFirstResult(10).setMaxResult(20).list();]]>
                        </programlisting>
                    </listitem>
                    <listitem>
                        <para>分页函数:Page pagedQuery(Criteria criteria, int pageNo, int pageSize) 和Page pagedQuery(String hql, int pageNo, int pageSize, Object... args)</para>
                        <para>Page是自行封装分页类，其中最主要的属性是totalCount和result，pagedQuery与hibernate自身分页查询的差别是先运行一次count，获得符合条件的总记录数。</para>
                        <para>如果查询不需要总记录数，用普通的hibernate API，加上setFirstResult(),setMaxResult()就解决，不需要pagedQuery()。</para>
                    </listitem>
                    <listitem>
                        <para><![CDATA[判别对象属性在数据库中唯一的函数:isUnique(Class<T> entityClass,Object entity,String names)。]]></para>
                    </listitem>
                </orderedlist>
            </sect3>
            <sect3>
                <title>HibernateEntityDao</title>
                <para>所有UserManager, RoleManager之类只管理一类对象的Manager类的基类，只需要在类定义处声明Entity类型即可</para>
                <programlisting><![CDATA[
public class UserManager extends HibernateEntityDao<Book> {
}]]>
                </programlisting>
                <para>如果需要操作其他的Entity，比如UserManager可能需要处理Role，可以注入RoleManager。无需担心事务的问题，JavaEE的默认事务模型已能很好处理。</para>
                <para>如果没有对应的RoleManager，或者各种原因不想注入的话，可以使用UserManager继承自HibernateGenericDao的带entityClass参数的函数来操作Role的增删改，如Role role = this.get(Role.class, 1);</para>
            </sect3>
            <sect3>
                <title>HibernateExtendDao</title>
                <itemizedlist>
                    <listitem>
                        <para>支持对象不能被直接删除，只能设置状态列为无效。</para>
                        <para>接口UndeleteableEntityOperation，定义了要支持此功能必须实现的函数。</para>
                        <para> 可以有接口(UndeletableEntity)和annotation(@Undeletable)两种形式来定义无效列，annotation列形式还可以定义标识对象已删除的状态属性的名称，用接口则必须实现setStatus()接口，在里面操作实际的状态属性。</para>
                    </listitem>
                    <listitem>
                        <para>重载save()，在保存前先调用onValid() 函数</para>
                    </listitem>
                    <listitem>
                        <para>增加find(Map map) 接口</para>
                        <para> 默认查找与map中全部条件相同的entity。</para>
                        <para>条件的比较运算符默认为相同，用户也可以为属性名加上like_，largerthen_ 这样的前缀，则使用相应的运算符作比较(未完成)</para>
                    </listitem>
                </itemizedlist>
            </sect3>
        </sect2>
    </sect1>

    <sect1>
        <title>使用envers进行版本控制</title>
        <para>envers是jboss的一个项目，它可以对实体类进行版本控制，用法依然是annotation加listener，它会对每个实体类创建额外的数据库表。</para>
        <para>为了监听版本更新，需要添加如下监听器：</para>
        <programlisting><![CDATA[
<property name="hibernate.ejb.event.post-insert" value="org.jboss.envers.event.VersionsEventListener" />
<property name="hibernate.ejb.event.post-update" value="org.jboss.envers.event.VersionsEventListener" />
<property name="hibernate.ejb.event.post-delete" value="org.jboss.envers.event.VersionsEventListener" />
<property name="hibernate.ejb.event.pre-collection-update" value="org.jboss.envers.event.VersionsEventListener" />
<property name="hibernate.ejb.event.pre-collection-remove" value="org.jboss.envers.event.VersionsEventListener" />
<property name="hibernate.ejb.event.post-collection-recreate" value="org.jboss.envers.event.VersionsEventListener" />]]>
        </programlisting>
        <para>实例代码：</para>
        <programlisting><![CDATA[
import org.jboss.versions.Versioned;

import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.GeneratedValue;
import javax.persistence.Column;

@Entity
@Versioned
public class Blog {
    @Id
    @Column(length=32)
    private String id;

    @Versioned
    @Column(length=100)
    private String title;

    @Column(length=2000)
    private String date;

    @Versioned
    @ManyToOne
    private String body;

    @ManyToOne
    private Author author;
    // add getters, setters, constructors, equals and hashCode here
}]]>
        </programlisting>
        <para>如何取得版本库的信息：</para>
        <programlisting><![CDATA[
VersionsReader reader = VersionsReaderFactory.get(entityManager);

// get Blog all versions id
List<Number> versions = reader.getRevisions(Blog.class, "1"/*blog id*/);
for (Number version : versions) {
    Blog blog = reader.find(Blog.class, "1", version);
}]]>
        </programlisting>
    </sect1>

    <sect1>
        <title>Spring JDBCTemplate</title>
        <para>当报表查询必须使用SQL时，大家有三种选择：</para>
        <orderedlist>
            <listitem>
                <para>使用Hibernate 的sql 查询函数将查询结果对象转为对象。</para>
            </listitem>
            <listitem>
                <para>使用Hibernate session的getConnection 获得JDBC Connection，然后进行纯JDBC API操作。（getConnection()已经被废弃了）</para>
            </listitem>
            <listitem>
                <para>选择把JDBC Template作为一种很不错的JDBC Utils来使用。</para>
            </listitem>
        </orderedlist>
        <para>JDBCTemplate的使用很简单，只要在ApplicationContext文件里定义一个jdbcTemplate节点，POJO获得注入后可以直接执行操作，不需要继承什么基类，具体例子见销售报表查询类SaleReportManager：</para>
        <programlisting><![CDATA[
<bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
    <property name="dataSource" ref="dataSource"/>
</bean>]]>
        </programlisting>
        <programlisting><![CDATA[
SqlRowSet rs = jdbcTemplate.queryForRowSet(sql, params);]]>
        </programlisting>
        <para>jdbcTemplate有很多的ORM化回调操作将返回结果转为对象列表，但很多时候还是需要返回ResultSet，Spring有提供一个类似ResultSet的，实现JDBC3.0 RowSet接口的Spring SqlRowSet。</para>
        <para>注意jdbcTemplate尽量只执行查询操作，莫要进行更新，否则会破坏Hibernate的二级缓存体系。</para>
    </sect1>

    <sect1>
        <title>Spring Error Code 统一翻译</title>
        <para>Spring的Error Code统一翻译机制挺实用的，可以把各种数据库的各种Error Code分成六大类，分别转为6种异常抛出，让你可以用异常捕获机制捕获自己感兴趣的异常。</para>
        <para>比如我最关心的，对象因为有级联引用，不应该被删除的情况，就属于dataIntegrityViolation(数据校验)异常，同属于此的错误还有值的唯一性失败等。这样，我在代码里只要捕捉DataInterityViolation就可以了，不用管什么数据库，也不用hard code几种需要同样处理的Error Code.</para>
        <para>这个翻译机制的配置很简单，spring已提供了默认的error code--异常影射表，但还不够完全，你可以将sql-error-codes.xml文件copy到src根目录，spring就会转去读你的加强版。</para>
        <para>springside的src目录里有此配置文件，对hsqldb的error code作了加强，你打开来看一下就知道如何]配置的了。</para>
        <programlisting><![CDATA[
<bean id="HSQL" class="org.springframework.jdbc.support.SQLErrorCodes">
    <property name="databaseProductName">
        <value>HSQL Database Engine</value>
    </property>
    <property name="badSqlGrammarCodes">
        <value>-22,-28</value>
    </property>
        <property name="dataIntegrityViolationCodes">
            <value>0,-8,-9</value>
        </property>
    </bean>]]>
        </programlisting>
    </sect1>

    <sect1>
        <title>bba96 说明<emphasis>（待研究）</emphasis></title>
        <para>其实比较青睐bba96中的高级查询语法，大大简化了left join查询。据说它还解决了分页查询中having子句影响查询结果的问题，但是终因为缺乏注释和单元测试，迟迟无法动手。</para>
        <para>如果你使用spring+hibernate，而又不喜欢hibernate criteria的麻烦，不妨尝试一下bba96，作为基于Hibernate+Spring的持久层的架构应用，完全可以独立加入到你的项目中，让你可以把主要精力放到业务方面。</para>
        <para>com.bba96.tiger.service.DefaultEntityManager 是使用最多的类，提供了很多单层逻辑的便利方法给你使用，其中也包括执行hsql或者sql查询/更新的方法，如果你要多层次逻辑的条件查询可以自己组装QueryObject，参见com.bba96.tiger.util.QueryWebUtils的main函数。</para>
        <para>同时bba96还提供给你在view层自由增加查询的能力，使用起来很方便。以下就是SpringSide中 org.springside.modules.webwork.action.SSActionSupport 使用bba96实现方便的view查询的例子：</para>
        <programlisting><![CDATA[
protected QueryWebParameter search;//定义接受查询参数的对象
public QueryWebParameter getSearch() {
    return search;
}
public void setSearch(QueryWebParameter search) {
    this.search = search;
}
public Page getPaginationResults() {
    //此处可对search处理，进行参数删减以实现灵活的功能或是增强安全
    if (search == null) {
        search = new QueryWebParameter();
    }
    if (search.getPageSize() <= 0) {
        search.setPageSize(Constants.DEFAULT_PAGE_SIZE);//设置默认每页记录数
    }
    return getEntityManager().findByWebParameter(getEntityClass(), search);//执行查询返回分页的结果
}]]>
        </programlisting>
        <para>action中就是上面这段话就可对所有的对象实现基本的查询功能。在jsp的要增加对应字段的查询只需遵循以下写法：</para>
        <para>对每个需要查询的属性要定义三个变量，search.name, search.operator, search.value</para>
        <para>其中search对应上面的QueryWebParameter的变量search</para>
        <para>name对应属性名</para>
        <para>若是关联其它对象的非主键属性需用冒号定义别名。</para>
        <para>规则 -- 描述关联对象的属性:别名.该关联对象的属性</para>
        <para>举例 -- groups:g.name，支持多极别名，如groups.g.users:gu.name，这里gu就是g.users的别名</para>
        <para>operator对应逻辑操作符，参考com.bba96.tiger.query.QueryParam</para>
        <para>value对应值，默认为String类型，可在最后加下划线加类型如_Long或_Date?mm-DD</para>
        <para>具体写法参见/webapps/ww/admin/book_list.ftl，关于更多view的逻辑，参见com.bba96.tiger.util.QueryWebUtils</para>
        <para>在Spring中的配置也非常简单，如下所示，更新信息参见src/resources/applicationContext-webwork.xml</para>
        <programlisting><![CDATA[
<bean id="objectDao" class="com.bba96.tiger.dao.hibernate.HibernateObjectDAO">
    <property name="sessionFactory">
        <ref bean="sessionFactory"/>
    </property>
</bean>]]>
        </programlisting>
        <programlisting><![CDATA[
<bean id="defaultEntityManager" parent="baseTxService">
    <property name="target">
        <bean class="com.bba96.tiger.service.DefaultEntityManager">
            <property name="objectDAO">
                <ref local="objectDao"/>
            </property>
        </bean>
    </property>
</bean>]]>
        </programlisting>
    </sect1>

</chapter>













