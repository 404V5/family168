<?xml version="1.0" encoding="UTF-8"?>
<chapter xml:id="springsecurity">
    <title>Spring Security权限管理<emphasis>（待整理）</emphasis></title>
    <para>照搬springside-2.0的权限模型，实现User用户 - Role角色 - Resource资源三种组成的RBAC模型。</para>
    <sect1>
        <title>默认角色名称都要以ROLE_开头</title>
        <para>稍微注意一下，默认角色名称都要以ROLE_开头，否则不会被计入权限控制，如果需要修改，就在xml里配个什么前缀的。</para>
        <para>参考springside中的例子，可以用过配置roleVoter的rolePrefix来改变这个前缀</para>
        <programlisting><![CDATA[<!--
         必须是以rolePrefix设定的value开头的才会进行投票,否则为弃权
     -->
    <bean id="roleVoter" class="org.acegisecurity.vote.RoleVoter">
        <property name="rolePrefix" value="AUTH_"/>
    </bean>]]>
        </programlisting>
    </sect1>
    <sect1>
        <title>关于Voter这个投票者的含义终于有一点儿了解了。</title>
        <para>实际上并没有翻译的字面含义那么有血有肉，实际上就是一些条件，判断权限的时候，这些条件有三个状态。弃权，通过，禁止。最后通过你在xml里配置的策略来决定到底是不是让你访问这个需要验证的对象。</para>
        <para>acegi自己提供的策略有三个：</para>
        <itemizedlist>
            <listitem>
                <para>UnanimousBased.java只要有一个Voter不能完全通过权限要求，就禁止访问。这个太可怕了，我今天晚上就载在它上面了。就因为我给所有的资源设置了两个角色，但当前的用户只拥有其中一个角色，就导致这个用户因为权限不够，所以无法继续访问资源了。简直无法理喻啊。</para>
            </listitem>
            <listitem>
                <para>AffirmativeBased.java只要有一个Voter不能通过权限要求，就禁止访问。这里应该是一个最小通过，就是说至少满足里其中一个条件就可以通过了。</para>
            </listitem>
            <listitem>
                <para>ConsensusBased.java只要通过的Voter比禁止的Voter数目多就可以访问了。嘿嘿。</para>
            </listitem>
            <listitem>
                <para>最后我当然选择AffirmativeBased.java，这样，我给一个资源配置几个角色，用户只要满足其中一个角色就可以访问啦。这样更正常一些啊。</para>
            </listitem>
        </itemizedlist>
    </sect1>
    <sect1>
        <title>关于同一用户重复登录的问题</title>
        <para>在filterChainProxy里面加上concurrentSessionFilter</para>
        <programlisting><![CDATA[<bean name="filterChainProxy" class="org.acegisecurity.util.FilterChainProxy" >
  <property name="filterInvocationDefinitionSource">
   <value>
    CONVERT_URL_TO_LOWERCASE_BEFORE_COMPARISON
    PATTERN_TYPE_APACHE_ANT
    /**=httpSessionContextIntegrationFilter,logoutFilter,authenticationProcessingFilter,anonymousProcessingFilter,concurrentSessionFilter,exceptionTranslationFilter,filterInvocationInterceptor
   </value>
  </property>
</bean>]]>
        </programlisting>
        <para>配置concurrentSessionFilter和concurrentSessionController</para>
        <programlisting><![CDATA[<bean id="concurrentSessionFilter" class="org.acegisecurity.concurrent.ConcurrentSessionFilter">
  <property name="sessionRegistry">
   <ref bean="sessionRegistry"/>
  </property>
  <property name="expiredUrl">
   <value>/login.action?status=expired</value>
  </property>
 </bean>

 <!-- 可以阻止某个用户名在已经成功登录进web应用的同时再进行一次成功的登录 -->
 <bean id="concurrentSessionController" class="org.acegisecurity.concurrent.ConcurrentSessionControllerImpl">
  <property name="maximumSessions"><value>1</value></property>
  <property name="sessionRegistry"><ref local="sessionRegistry" /></property>
  <!-- property name="exceptionIfMaximumExceeded" value="true"  /-->
 </bean>
 <bean id="sessionRegistry" class="org.acegisecurity.concurrent.SessionRegistryImpl" />]]>
        </programlisting>
    </sect1>
    <sect1>
        <title>使用Filter拦截URL请求</title>
        <para>使用在web.xml中配置的一系列filter实现对URL请求的拦截。</para>
    </sect1>
    <sect1>
        <title>使用interpreter拦截METHOD调用</title>
        <para>采用aop方式，实现方法调用拦截。</para>
    </sect1>
    <sect1>
        <title>ACL如何实现？</title>
        <orderedlist>
            <listitem>
                <para>根据springside的JIRA描述，实现基本的层次式ACL 管理，（Role A拥有部门A的审批，部门B的查看权限, 请假单属于部门A，则Role A有该单的审批权限）。与插件式的规则引擎管理。</para>
            </listitem>
            <listitem>
                <para>来自： <ulink url="http://www.blogjava.net/RongHao/archive/2006/12/14/87634.html"/>对acegi ACL扩展的构想</para>
                <para>扩展一：当你增加一条记录的同时向ACL表里插入权限信息，这个ss已经做到了，ss有一个借口标记那些domain需要ACL保护AclDomainAware。这里再扩展一个基类，目的很简单，当读出数据时附加上权限信息 <programlisting><![CDATA[
public class BasicAclDomain implements AclDomainAware {
    private int mask; // 权限
    getMask
    setMask
}

public class Contact extends BasicAclDomain]]>
                </programlisting></para>
                <para>扩展二：读取列表时进行数据过滤，原来的acegi在ACL的集合后处理会造成分页虎牙子。这里采用前拦截，在acl表里增加一个className字段，里面放上PO的类名，这样可以缩小数据查询范围。实际在读取集合时，先到acl表里完成分页，然后多的对contact的real id list，然后拦截实际DAO方法，动态改变SQL成select * from real_data where id in ({real id list})的形式。</para>
                <para>分页实际是对acl表里相应记录的分页，比如说取第10条到20条，实际是取acl表里响应记录的第10条到20条来动态改变sql。</para>
                <para>这个可以写一个专门用来拦截的类SecurityDAO方法，findByPageACL(query, page),ContactServiceImpl中getAllContacts方法强制调用该方法。</para>
                <tip>这个方法在javaeye中看到了讨论，问题就在于：real id list过大时，数据库会将sql剪切。所以数据量大的时候没法用，还有人说如果需要动态设置其他查询或排序条件，还会有问题，具体是什么就没说，可能是解析出问题，或者效率问题</tip>
                <para>扩展三：后拦截。这里AFTER_ACL_COLLECTION_READ和AFTER_ACL_READ的目的就很简单了，因为他们不再进行数据过滤，他们只是把用户对每条记录的mask取最大权限就OK了，然后往PO级setMask。这样PO带了权限信息到页面上行就非常好处理了。比如button的显示等等。</para>
                <para>扩展四：封装AclService，对单条记录的ACL权限管理。比如增加权限，修改权限，删除权限。这个acegi从1.0.3已经开始加入了。</para>
                <para>还未实现的构想一：PO创建向ACL表里插入权限信息时，可以配置不同策略：比如通讯录创建一条新信息只能创建者可以看并管理，儿你往请假表里插入一条新信息后，不仅你了，你的上司也可以同时看到。（这个还是比较easy的）。</para>
                <para>还未实现的构想二：用户数据要实现数据库排序。需要在ACL_OBJECT_IDENTITY里增加几个额外字段，把PO相应的排序字段同步更新到ACL表中。什么？不好做？写配置文件啊！再对PO的update进行后拦截，想法就这样。实现？？</para>
            </listitem>
        </orderedlist>
    </sect1>
    <sect1>
        <title>关于用户权限管理的问题，有了一些自己的想法</title>
        <sect2>
            <title>部门概念</title>
            <para>无论是springside-1.0中的user - role - authority - resource四层结构，还是springside-2.0中的user - role - resource三层结构，都是演示了无部门的权限模型。</para>
            <para>而在实际应用中，使用了添加了部门的权限模型，就是说在user - role - resource中又增加了dept的部分，这样做的好处是，不同部门可以使用相同名称的角色，在设置角色权限的时候，根据部门分别授权，而用户登陆之后，根据本身处在的不同部门，就可以被授予不同的权限。</para>
            <para>这种权限模型的最大好处是，当员工发生平级调动的时候，比如技术部的普通员工，调动到客户服务部之后， 因为角色名都是普通员工，只需要改动此员工的部门，不需要对他的权限设置再进行处理，就可以让他使用新工作岗位的功能权限。</para>
            <para>但问题是，模型增加了一个dept，却大大的增加了模型的复杂程度，原本role - resource之间的多对多关系，变成了role - dept - resource三者之间的网状多对多对多的关系，role与dept结合之后，才能唯一决定使用的权限。如果把角色设置为，软件部项目经理，硬件部项目经理，感觉也是怪怪的，所以说也是应该让部门与角色结合，这样就可以使用诸如“项目经理”这种同名角色，在使用角度上来说是更便利了。但害怕出现与部门锁定的情况，影响跨部门角色的设置与使用。</para>
            <para>想到一个可能实现的解决方法，那就是让dept仅仅与role关联，我们在显示页面中看到的是一个角色名，而实际上数据库中保存着多个角色列表，这些角色列表分别对应每个部门，这样就达到role与resource单独管理，免得加入dept的关系，让数据模型变得更加复杂。现在感觉这样的设置方式，可以达到不增加程序模型的复杂度，同时可以提升用户体验的作用，只不过在设置role的时候，还需要多考虑一下具体的细节问题，比如默认的角色应该是可以在所有部门下使用的（不属于任何一个部门，只是一种缺省情况下的考虑。），增加一个特定部门的角色，就应该覆盖掉默认的角色权限。这个时候再给用户分配角色的时候，如何选择特定的角色，角色分配权限的时候。这些时候就要在界面易用性上下工夫了。</para>
            <para>现在对如何实现这样的模型完全没有思路。而且角色权限的时候，很可能要根据部门把一个角色的权限分配多次，这样是不是也让管理人员的工作量提高了呢？而且不知道实际中这样的是不是真正给工作带来便利。所以有待进一步的研究啊。</para>
            <para>假想使用部门概念的情况：公司中人员的技术能力差别不显著，不同部门的员工可以随意变动，而且不同部门中的员工职务名称也是类似的，技术部的一般员工，高级员工，经理，客户服务部的一般员工，高级员工，经理。而且每个员工通常只分配一种角色，这样对角色进行统一管理的时候，以及平级调动的时候就显得很方便。</para>
        </sect2>
        <sect2>
            <title>职务问题</title>
            <para>在公司中，人员都会有自己的职务分属，也是根据职务来决定自己负责的工作与权限。但系统中常常使用角色role来代替职务来发生作用，约束人员的权限。能不能在系统中使用职务来代替角色呢？我认为是不可以的。</para>
            <para>第一，人员的权限可能会频繁发生变动，而职务的变动可能与权限的变动相比，则稳定得多。比如经常发生在繁忙的时候一个人身兼数职的情况，而在相对清闲的时候，他又会继续去做自己的本职工作。为了解决这种情况，我们就需要抽象出粒度更细的角色，来负责动态分配用户可能经常改变的权限。</para>
            <para>第二，职务是一种树状结构，而角色更趋向于扁平结构。实际中，职务上严格区分上下级关系的，似乎更能体现出不同用户的权限大小，而角色可以当作是一组权限的集合，角色之间没有必然的上下级关系，仅仅是用来简化操作，便于理解的一种手段。从这个角度上来说，扁平式的角色更利于程序实现。</para>
            <para>第三，职务是来自现实工作中的，一种模糊的称谓，是一种感性的认识，更利于人们的记忆和浏览。而角色是为了程序的数学模型，而抽象出来的，更精确的表示功能集合的一个理性概念，更利于逻辑实现。</para>
        </sect2>
    </sect1>
    <sect1>
        <title>acegisecurity-1.0.5新ACL模型</title>
        <para>听说从1.0.3时代开始，就提供了acls包，作为新的ACL模型，在下之前未接触过旧的ACL模型，冒昧直接从新模型开始了。</para>
        <para>研究acls是从发布包中的contact例子开始的。感觉控制都集中在manager层之内，只对ADMINISTRATOR,READ,DELETE做控制，administrator和delete依然是用aop切method，例子里是写到xml里，考虑怎么跟springside2提供的基础结合。</para>
        <para>read方面做了特殊处理，作为后检验，让getAll这种方法，每次返回的数据，先交给拦截器检验，没有权限就从返回的结果列表中删除，这样来实现，各自看各自的数据。问题就是分页的时候可能出现虎牙子（每页显示记录数不同）。</para>
        <programlisting><![CDATA[
CREATE TABLE ACL_SID(
    ID BIGINT GENERATED BY DEFAULT AS IDENTITY(START WITH 100) NOT NULL PRIMARY KEY,
    PRINCIPAL BOOLEAN NOT NULL,
    SID VARCHAR_IGNORECASE(100) NOT NULL,
    CONSTRAINT UNIQUE_UK_1 UNIQUE(SID,PRINCIPAL)
);
CREATE TABLE ACL_CLASS(
    ID BIGINT GENERATED BY DEFAULT AS IDENTITY(START WITH 100) NOT NULL PRIMARY KEY,
    CLASS VARCHAR_IGNORECASE(100) NOT NULL,
    CONSTRAINT UNIQUE_UK_2 UNIQUE(CLASS)
);
CREATE TABLE ACL_OBJECT_IDENTITY(
    ID BIGINT GENERATED BY DEFAULT AS IDENTITY(START WITH 100) NOT NULL PRIMARY KEY,
    OBJECT_ID_CLASS BIGINT NOT NULL,
    OBJECT_ID_IDENTITY BIGINT NOT NULL,
    PARENT_OBJECT BIGINT,
    OWNER_SID BIGINT,
    ENTRIES_INHERITING BOOLEAN NOT NULL,
    CONSTRAINT UNIQUE_UK_3 UNIQUE(OBJECT_ID_CLASS,OBJECT_ID_IDENTITY),
    CONSTRAINT FOREIGN_FK_1 FOREIGN KEY(PARENT_OBJECT) REFERENCES ACL_OBJECT_IDENTITY(ID),
    CONSTRAINT FOREIGN_FK_2 FOREIGN KEY(OBJECT_ID_CLASS) REFERENCES ACL_CLASS(ID),
    CONSTRAINT FOREIGN_FK_3 FOREIGN KEY(OWNER_SID) REFERENCES ACL_SID(ID)
);
CREATE TABLE ACL_ENTRY(
    ID BIGINT GENERATED BY DEFAULT AS IDENTITY(START WITH 100) NOT NULL PRIMARY KEY,
    ACL_OBJECT_IDENTITY BIGINT NOT NULL,
    ACE_ORDER INTEGER NOT NULL,
    SID BIGINT NOT NULL,
    MASK INTEGER NOT NULL,
    GRANTING BOOLEAN NOT NULL,
    AUDIT_SUCCESS BOOLEAN NOT NULL,
    AUDIT_FAILURE BOOLEAN NOT NULL,
    CONSTRAINT UNIQUE_UK_4 UNIQUE(ACL_OBJECT_IDENTITY,ACE_ORDER),
    CONSTRAINT FOREIGN_FK_4 FOREIGN KEY(ACL_OBJECT_IDENTITY) REFERENCES ACL_OBJECT_IDENTITY(ID),
    CONSTRAINT FOREIGN_FK_5 FOREIGN KEY(SID) REFERENCES ACL_SID(ID)
);
CREATE TABLE USERS(
    USERNAME VARCHAR_IGNORECASE(50) NOT NULL PRIMARY KEY,
    PASSWORD VARCHAR_IGNORECASE(50) NOT NULL,
    ENABLED BOOLEAN NOT NULL
);
CREATE MEMORY TABLE AUTHORITIES(
    USERNAME VARCHAR_IGNORECASE(50) NOT NULL,
    AUTHORITY VARCHAR_IGNORECASE(50) NOT NULL,
    CONSTRAINT FK_AUTHORITIES_USERS FOREIGN KEY(USERNAME) REFERENCES USERS(USERNAME)
);
CREATE UNIQUE INDEX IX_AUTH_USERNAME ON AUTHORITIES(USERNAME,AUTHORITY);
CREATE MEMORY TABLE CONTACTS(
    ID BIGINT NOT NULL PRIMARY KEY,
    CONTACT_NAME VARCHAR_IGNORECASE(50) NOT NULL,
    EMAIL VARCHAR_IGNORECASE(50) NOT NULL
);
]]>
        </programlisting>
        <mediaobject>
            <imageobject role="fo">
                <imagedata fileref="images/acls01.jpg" format="JPG" align="center"/>
            </imageobject>
            <imageobject role="html">
                <imagedata fileref="images/acls01.jpg" format="JPG" align="center"/>
            </imageobject>
        </mediaobject>
        <sect2>
            <title>ACL_CLASS保存支持的类名</title>
        </sect2>
        <sect2>
            <title>ACL_SID应该保存的是用户名，和这个用户目前是否有效</title>
        </sect2>
        <sect2>
            <title>ACL_OBJECT_IDENTITY里有三个外键，分别是</title>
            <orderedlist>
                <listitem>
                    <para>object_id_class，表示控制的是哪个类</para>
                </listitem>
                <listitem>
                    <para>parent_object，自关联外键，用处未知，可能用于支持继承</para>
                </listitem>
                <listitem>
                    <para>owner_sid，属主，与ACL_SID对应</para>
                </listitem>
            </orderedlist>
            <para>还剩下两个字段：</para>
            <para>object_id_identity，表示控制的类的id号，与数据库里的主键对应</para>
            <para>entries_inheriting，类型是boolean，用来标记是否从超类继承属性的吗？</para>
        </sect2>
        <sect2>
            <title>ACL_ENTRY，用来保存每个SID（用户）与OBJECT之间权限关系了</title>
            <para>两个外键：ACL_OBJECT_IDENTITY和SID与两个表进行外键关联，从这里可以看到，实际上它就是一个中间表而已，让两个表做多对多关系。</para>
            <para>ace_order应该是排序吧？</para>
            <para>mask是用来确认权限，administrator, read, delete以及其他一些组合。</para>
            <para>granting，boolean型，应该是判断是否进行了授权</para>
            <para>audit_success，boolean型，不懂什么意思</para>
            <para>audit_failure，boolean型，不懂什么意思</para>
        </sect2>
    </sect1>

</chapter>
