<?xml version="1.0" encoding="UTF-8"?>
<chapter xml:id="ajax">
    <title>ajax</title>

    <sect1>
        <title>JSCalendar日历控件</title>
        <para>日历控件我们使用dynarch的JSCalendar: http://www.dynarch.com/projects/calendar/下载包中有完整的sample 和 文档。</para>
        <para>可以直接包含components/calendar/calendar.jsp获得所需的js和css文件。</para>
        <programlisting><![CDATA[
<link href="${ctx}/components/calendar/skins/theme.css" type="text/css" rel="stylesheet"/>
<script type="text/javascript" src="${ctx}/components/calendar/calendar.js"></script>
<script type="text/javascript" src="${ctx}/components/calendar/calendar-setup.js"></script>
<script type="text/javascript" src="${ctx}/components/calendar/lang/calendar-en.js"></script>]]>
        </programlisting>
        <para>另外，两个原版的中文语言文件calendar-zh.js有误，springside作了修正，补回了缺失的 Calendar._FD = 0; 语句。</para>
        <para>基本使用代码如下：</para>
        <programlisting><![CDATA[
<%@ include file="/components/calendar/calendar.jsp" %>
<input type="text" name="publisherDate" id="publisherDate">
<button id="publisherDateBt" type="button" class="button"> ...</button>
<script type="text/javascript">
Calendar.setup({
    inputField : "publisherDate",
    ifFormat   : "%Y-%m-%d",
    button     : "publisherDateBt"
});
</script>]]>
        </programlisting>
        <para>注意，日历控件还可以显示小时和分钟，只要设置Calendar.setup中的参数即可，详细看JSCalendar自带的文档。</para>
    </sect1>

    <sect1>
        <title>JQuery </title>
        <para>Prototype.js，JQuery这类Javascript库，有助于跨浏览器的Javascript，并简化对象选择、DOM操作、Ajax操作。</para>
        <sect2>
            <title>基本功能</title>
            <para>JQuery的基本功能包括DOM对象选择设置，如：</para>
            <programlisting><![CDATA[
$("#loginName").val("calvin");]]>
            </programlisting>
            <para>其中#loginName是CSS语法，获得页面id为loginName的元素。一般按ID获取对象已足够，想使用更高级的CSS+XPath的获取方法，参考JQuery的Selector文档。</para>
            <para>注意JQuery1.3后，按属性查询对象的语法已取消@，下面语句为name为"gender"的radio，checked值为"male"的box。</para>
            <programlisting><![CDATA[
$('input:radio[name=gender]').val(['male']);]]>
            </programlisting>
        </sect2>
        <sect2>
            <title>Ajax</title>
            <para>ajax的几种常用法，包括：</para>
            <itemizedlist>
                <listitem>
                    <para>将Form中的内容序列化成字符串动态提交。</para>
                </listitem>
                <listitem>
                    <para>动态获取文本内容，更新本页内容。</para>
                </listitem>
                <listitem>
                    <para>动态获取JSON内容，更新本页内容。</para>
                </listitem>
                <listitem>
                    <para>基于JSONP，跨域获取html内容，更新本页内容。</para>
                </listitem>
                <listitem>
                    <para>注意要避免缓存，要不服务端返回时输出no-cache参数，要不使用JQuery中最麻烦的用法$.ajax()方法来设定非缓存参数，详见JQuery官方文档。</para>
                </listitem>
            </itemizedlist>
        </sect2>
        <sect2>
            <title>Valiation plugin</title>
            <para>Validation是著名的客户端输入校验plugin，可进行非空、数字等常规校验，也可以远程ajax判断用户名是否唯一，详见JQuery Plugin资料。</para>
        </sect2>
    </sect1>

    <sect1>
        <title>DWR</title>
        <para>DWR是一种新的Ajax方式，有别于访问URL的传统模式，DWR自己在服务端作了一个通用的Service层Gateway(Proxy)，使得客户端的Javascript可以直接操作远程的服务器端的Service层，再配合TrimPath JSTemplate以Template而不是Dom Builder的方式将Service层返回的POJO渲染成复杂的页面，创造一种新的纯Ajax编程模式。</para>
        <para>DWR的官方网站：http://directwebremoting.org/dwr/</para>
        <para>TrimPath JSTemplate的官方网站：http://code.google.com/p/trimpath/。</para>
        <para>TrimPath JSTemplate以类似Freemarker的语法用Javascript在IE客户端渲染页面，非常好用：</para>
        <programlisting><![CDATA[
{for u in data}
    <p>${u.name}</p>
{/for}]]>
        </programlisting>
        <para>服务端配置文件</para>
        <para>在web.xml中添加dwr-invoker servlet，新建一个dwr.xml，配置导出的service服务以及要转换到客户端javascript的bean。如果安全要求不严格，可以很简单就配完，如果严格就麻烦一点，见dwr的注释。</para>
        <para>客户端页面</para>
        <para>增加DWR一个动态生成的JavaScript及两个标准的工具js：</para>
        <programlisting><![CDATA[
<script type="text/javascript" src="dwr/interface/UserService.js"></script>
<script type="text/javascript" src="dwr/engine.js"></script>
<script type="text/javascript" src="dwr/util.js"></script>]]>
        </programlisting>
        <para>使用UserService对象：</para>
        <para>UserService.js的名字在服务端dwr.xml里已定义，在其后的Javascript里，就可以像在Java里面一样使用UserService对象和它的方法，如</para>
        <programlisting><![CDATA[
UserService.getAll(function(data) {
    document.getElementById("result").innerHTML = TrimPath.processDOMTemplate('jst', {data:data});
});]]>
        </programlisting>
        <para>参数是在响应返回时进行处理的回调函数。</para>
        <para>使用TrimPath JSTemplate渲染返回的POJO：</para>
        <para>下载并拷贝trimpath-template-1.0.38.js到任意目录，然后在页面加入</para>
        <programlisting><![CDATA[
<script type="text/javascript" src="components/jstemplate/trimpath-template-1.0.38.js"></script>]]>
        </programlisting>
        <para><![CDATA[然后按照Trimpath的简单语法在<textarea>里编写模版并把POJO放到模版里渲染]]></para>
        <para><![CDATA[具体使用见dwr.html中的<textarea id="jst" >节点和dwr中的回调函数]]>。</para>
    </sect1>

    <sect1>
        <title>DWR推技术</title>
        <para>DWR2.0.x的推技术以推发送消息，适用于ChatRoom，股票信息显示等场景，优于现在JS定时轮询服务端的策略，大大节省服务端的资源（数据无变化时不需要应答客户端的定时查询）。</para>
        <para>推技术的经典范例是DWR Examples里的ChatRoom。</para>
        <para>推消息的接收页</para>
        <itemizedlist>
            <listitem>
                <para>第一，引入dwr及那个负责执行推操作的Java类(NoticeService)的js</para>
                <programlisting><![CDATA[
<script type="text/javascript" src="dwr/interface/NoticeService.js"></script>
<script type="text/javascript" src="dwr/engine.js"></script>
<script type="text/javascript" src="dwr/util.js"></script>]]>
                </programlisting>
            </listitem>
            <listitem>
                <para>第二，设定任意的接收推信息的js函数</para>
                <programlisting><![CDATA[
function receiveMessages(message) {
    $('result').innerHTML += "<p>收到消息：" + message + "</p>";
}]]>
                </programlisting>
            </listitem>
            <listitem>
                <para>第三，在body的onload里设定ReverseAjax=true。</para>
                <programlisting><![CDATA[
<body onload="DWREngine.setActiveReverseAjax(true);">]]>
                </programlisting>
            </listitem>
        </itemizedlist>
        <para>负责推送消息的Java类</para>
        <programlisting><![CDATA[
public class NoticeService {
    public void send(String message) {
        WebContext wctx = WebContextFactory.get();
        ScriptBuffer script = new ScriptBuffer();
        script.appendScript("receiveMessages('").appendData(message)
              .appendScript("');");

        ServerContext sctx = ServerContextFactory.get(wctx
                .getServletContext());
        Collection<ScriptSession> pages = sctx.getScriptSessionsByPage(
                "/ajax/dwr-push.html");

        for (ScriptSession session : pages) {
            session.addScript(script);
        }
    }
}]]>
        </programlisting>
        <para>可见，用ScriptBuffer构造一段在客户端执行的JavaScript，然后使用WebContext，ServerContext定位需要发送的session进行发送。注意这里HardCode了URL路径来确定Subscriber，也可以像ChatRoom里面那样，用currenpage发给与NoticeService的调用者发起者在同一页的session。</para>
    </sect1>

    <sect1>
        <title>Ajax Upload，文件上传进度条</title>
        <para>Ajax Upload 实现了文件上传进度条的功能。</para>
        <para>首先简要说明一下AjaxUpload的原理：我们知道上传文件的时候实际上是客户端和服务器端创建了一个文件流，我们的目标就是实时得到这个文件到底上传了多少。我们只要在服务器端创建一个监听器监听这个文件流，很容易就能得到上传的大小，关键问题是怎么把当前一上传的大小返回给客户端显示出来。有了AJAX，这个还是问题么？用DWR远程调用服务端的FileUploadMontor取一下就OK了。</para>
        <para>所需文件</para>
        <itemizedlist>
            <listitem>
                <para>com.family168.ajaxupload包下的文件，来自springside</para>
            </listitem>
            <listitem>
                <para>webapp/components/ajaxupload目录的js与css文件</para>
            </listitem>
            <listitem>
                <para>DWR配置文件，负责与上传状态类的通信。</para>
            </listitem>
        </itemizedlist>
        <para>DWR的配置，主要配置DWR输出UploadMonitor的内容。</para>
        <para>页面需要加上css和ajaxupload.js脚本, dwr的js脚本，还有特定的div来显示进度条的效果。</para>
        <para>如果直接使用我们的封装的css和js，请在jsp页面直接引用</para>
        <programlisting><![CDATA[
<%@ include file="/components/ajaxupload/ajaxupload.jsp" %>]]>
        </programlisting>
        <itemizedlist>
            <listitem>
                <para>其中css文件指定了进度条的大小和颜色：</para>
                <programlisting><![CDATA[
#progressBar {
    padding-top: 5px;
}
#progressBarBox {
    width: 350px;
    height: 20px;
    border: 1px inset;
    background: #eee;
}
#progressBarBoxContent {
    width: 0;
    height: 20px;
    border-right: 1px solid #444;
    background: #9ACB34;
    text-align: right;
}]]>
                </programlisting>
            </listitem>
            <listitem>
                <para>js文件的内容：</para>
                <programlisting><![CDATA[
var fileInput;
var submitButton;
var progressBarBoxContent;
var progressBar;

function refreshProgress() {
  UploadMonitor.getUploadInfo(updateProgress);
}
function updateProgress(uploadInfo) {
  if (uploadInfo.inProgress) {
    progressBar.style.display = 'block';
    fileInput.style.display = 'none';
    fileInput.disabled = true;
    submitButton.disabled = true;

    var fileIndex = uploadInfo.fileIndex;
    var progressPercent = Math.ceil((uploadInfo.bytesRead / uploadInfo.totalSize) * 100);

    progressBarBoxContent.innerHTML = progressPercent + '%';
    progressBarBoxContent.style.width = parseInt(progressPercent * 3.5) + 'px';

    window.setTimeout('refreshProgress()', 100);
  } else {
    submitButton.disabled = false;
    fileInput.disabled = false;
    progressBar.style.display = 'none';
  }
  return true;
}

function startProgress(fileInputName, submitButtonName) {
  fileInput = document.getElementById(fileInputName);
  submitButton = document.getElementById(submitButtonName);
  progressBar = document.getElementById('progressBar');
  progressBarBoxContent = document.getElementById('progressBarBoxContent');
  if (fileInput \!= null && submitButton \!= null && progressBar \!= null && progressBarBoxContent \!= null) {
    progressBarBoxContent.innerHTML = '0%';
    window.setTimeout("refreshProgress()", 150);
    return true;
  } else {
    alert('Ajax Upload ERROR\!');
    return false;
  }
}]]>
                </programlisting>
            </listitem>
            <listitem>
                <para>加入进度条的div</para>
            </listitem>
            <listitem>
                <para>form的onsubmit事件</para>
                <para>在form的onsubmit事件里，要加上startProgress才能显示上传进度条。</para>
                <programlisting><![CDATA[
 onsubmit="return validateBookForm(this) && startProgress('imageFile','save')"]]>
                </programlisting>
            </listitem>
        </itemizedlist>
    </sect1>

    <sect1>
        <title>FCKEditor<emphasis>（待研究）</emphasis></title>
        <para>1.1 在http://www.fckeditor.net/ 下载FCKeditor 2.3 和FCKeditor.Java包 FCKeditor-2.3.jar</para>
        <para>1.2 参照FCKeditor.java的例子，配置web.xml 支持FCKEditor的图片文件上传和浏览Servlet.(见springmodules/fckeditor/ 中的web.xml)</para>
        <para>1.3 加入FCKeditor-2.3.jar和commons-fileupload.jar</para>
        <para>1.4但是fckeditor的文件实在太多了，让人没来由一阵心痛，删除以下目录及文件：</para>
        <para>1./_testcases,  /_samples,</para>
        <para>2./editor/_source,  /editor/skins/office2003, /editor/skins/silver, /editor/filemanager/upload, /editor/filemanager/browser/default/connector</para>
        <para>3./editor/lang 仅保留en.js，zh_cn.js</para>
        <para>4.在/的php,py等后缀名的文件</para>
        <para>5.删除plugin目录和dialog目录的spellcheck</para>
        <para>1.5 将干净的fck目录复制到项目中</para>
        <para>1.6 修改配置文件 fckconfig.js</para>
        <para>FCKConfig.DefaultLanguage  = 'zh-cn' ;</para>
        <para>删除spell check 相关的两处地方</para>
        <para>修改如下url,使用fckeditor servelt来做文件上传与目录浏览：</para>
        <para>在JSP中使用</para>
        <programlisting><![CDATA[
<c:set var="basepath"><c:url value="/fck/" /></c:set>
<FCK:editor id="descn" basePath="${basepath}" height="500px">
   <c:out value="${book.descn}" escapeXml="false" default="" />
</FCK:editor>]]>
        </programlisting>
    </sect1>

    <sect1>
        <title>dojo和extjs<emphasis>（待整理）</emphasis></title>
        <para>全站式Ajax框架</para>
        <para>喜欢extjs因为漂亮，讨厌dojo因为笨重，但是dojo支持绘图等很邪性的功能。</para>
        <para>js控件库，可选择基于yui,prototype,jquery或者ext-base底层实现，在这些底层基础上构筑了丰富的组件库。采用oo风格封装，易于使用和扩展。</para>
        <para>目前主要封装了Ext.lingo.JsonTree和Ext.lingo.JsonGrid，采用json格式的数据与后台交互，实现CURD等通用功能。</para>
        <sect2>
            <title>Ext.lingo.JsonTree</title>
            <para>树形结构，适用于单表自关联结构。</para>
            <orderedlist>
                <listitem>
                    <para>异步读取节点（不过管理分类的时候需要读取所有节点）</para>
                </listitem>
                <listitem>
                    <para>双击节点编辑节点内容</para>
                </listitem>
                <listitem>
                    <para>拖拽排序</para>
                </listitem>
                <listitem>
                    <para>右键弹出菜单，进行详细配置</para>
                </listitem>
            </orderedlist>
        </sect2>
        <sect2>
            <title>Ext.lingo.JsonGrid</title>
            <para>实现CURD功能的表格。</para>
            <orderedlist>
                <listitem>
                    <para>数据库端分页</para>
                </listitem>
                <listitem>
                    <para>checkbox全选，多选行</para>
                </listitem>
                <listitem>
                    <para>按字段模糊搜索</para>
                </listitem>
                <listitem>
                    <para>弹出对话框，进行新增或修改数据</para>
                </listitem>
            </orderedlist>
        </sect2>
    </sect1>

</chapter>



