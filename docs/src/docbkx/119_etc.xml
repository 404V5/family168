<?xml version="1.0" encoding="UTF-8"?>
<chapter xml:id="etc">
    <title>杂项</title>
    <sect1>
        <title>JDK-5.0</title>
        <sect2>
            <title>AutoBoxing</title>
            <para>不用在Integer和int之间费劲的转换了。</para>
        </sect2>
        <sect2>
            <title>For Loop Enhancement</title>
            <para>for (item : array)的形式支持Collection和Array。</para>
        </sect2>
        <sect2>
            <title>Annotation</title>
            <para>Annotation主要用于Hibernate</para>
            <para>泛型主要用于实现抽象HibernateEntityDao</para>
            <para>JDK5.0有SuppressWarnings，Deprecated和Override 三种内置的annotation：</para>
            <para>@Override，此标签一方面提醒用户这是个重载函数，另一方面保证了父类函数的参数或者名字改变时，子类如果没有跟着变化，就会编译不过。</para>
            <para><![CDATA[@SuppressWarnings("unchecked")，此标签可以让编译器忽略某种warning信息，比如减少JDK5.0的集合操作引入范型后无处不在的warning。因为有些非JDK5.0的开源库如hibernate, 函数返回的一定是List，而不会是List<User>，这时候IDE就会爆出很多warning。用SuppressWarning("unchecked")可以让IDE安静一些。其他常用warning还包括 @SuppressWarnings("unused") 和 SuppressWarnings("serial")]]></para>
            <para> @Deprecated，此标签以前写在JavaDoc里，现在提到annotation，注释已废弃的函数。用户使用该函数的话，编译时会得到"你用了废弃"的提示。</para>
        </sect2>
        <sect2>
            <title>静态import</title>
            <para>在使用EasyMock的测试用例里，静态导入EasyMock，使得可以直接使用其静态函数。看起来就像那些方法都属于本测试用例的。</para>
            <programlisting><![CDATA[
import static org.easymock.classextension.EasyMock.*;
public void testList() throws Exception {
    //录制bookManager findAllBy和getAllCategorys方法的期望值
    expect(mockManager.findBy(null, new HashMap())).andReturn(new Page());
    replay(mockManager);
}]]>
            </programlisting>
        </sect2>
        <sect2>
            <title>可变参数</title>
            <para>可变参数至少可以解决同时需要find(String sql,String arg), find(sql,String[] args) 这样的双接口问题。</para>
            <para>另外，在find函数里，find(sql,arg1,arg2,arg3) 也比find(sql,new String[]{arg1,arg2,arg3} ) 简洁明了。</para>
        </sect2>
    </sect1>
    <sect1>
        <title>公共Utils工具类。</title>
        <sect2>
            <title>Core Utils</title>
            <para>ReflectionUtils，提供强制直接访问隐含属性的能力，以及提供获取集合中元素的属性，组成一个List或字符串的函数。</para>
            <para>DozerMapperSingleton，Dozer4.0自带的DozerBeanMapperSingletonWrapper必须使用dozerBeanMapping.xml作参数初始化, 因此重新实现.</para>
            <para>JulOverSlf4jInit，调用SLF4JBridgeHandler.init()，初始化java.util.logging的日志请求到slf4j。</para>
        </sect2>
        <sect2>
            <title>Apache Commons Utils</title>
            <para>Commons BeanUtils，主要的反射操作Utils。</para>
            <para>BeanUtils能够获得便捷的反射函数封装及对嵌套属性，map,array型属性的读取。其中，BeanUtils将Bean属性读取转化为String,而PropertyUtils将按原来的属性原来的类型读取。</para>
            <para>Commons Lang StringUtils，主要的字符串操作Utils。</para>
            <para>Commons Lang ToStringBuilder，实现ToString函数，反射所有属性，用于Entity类的简单toString()函数。</para>
            <para>CollectionUtils里面有非常多的Utils方法，在做任何冗长的集合操作之前都应该先看看有没有相应的Utils。另外，Collections 补充了JDK所没有的Nullable Comparetor, Chain Comparetor等重要部分。</para>
            <para>Jakarta Configuration作为统一的Configuration接口，支持Properties, XML, DataBase</para>
            <itemizedlist>
                <listitem>
                    <para>可以一次读取多个properties文件</para>
                </listitem>
                <listitem>
                    <para>可以做getStringList(), getInt()这样的自动转换</para>
                </listitem>
                <listitem>
                    <para>可以支持ant那样的变量 my.color=$</para>
                </listitem>
                <listitem>
                    <para>可以用XML Path读取XML文件里的变量。</para>
                </listitem>
            </itemizedlist>
        </sect2>
        <sect2>
            <title>SpringUtils</title>
            <para>ResourceLoader，很好的用类似Ant的表达式，装载各种文件资源</para>
            <programlisting><![CDATA[
/WEB-INF/*-context.xml
    com/mycompany/**/applicationContext.xml
    file:C:/some/path/*-context.xml
    classpath:com/mycompany/**/applicationContext.xml]]>
            </programlisting>
            <para>Assert，使用Spring的Assert类，将对函数输入参数进行各种形式的校验，如集合非空，字符串含字符等，否则将抛出参数异常错误。</para>
        </sect2>
    </sect1>
    <sect1>
        <title>JavaMail。</title>
        <para>类org.springframework.mail.javamail.JavaMailSenderImpl提供了最直接的发送  我们直接用这个类来完成邮件的发送 </para>
        <para>Spring邮件抽象层的主要包为org.springframework.mail。它包括了发送电子邮件的主要接口MailSender和封装了简单邮件的属性如from, to, cc, subject, text的值对象叫做SimpleMailMessage。一个以MailException为root的checked Exception继承树，它们提供了对底层邮件系统异常的高级别抽象。请参考JavaDocs来得到关于邮件异常层次的更多的信息。</para>
        <para>为了使用JavaMail中的一些特色如MIME类型的消息，Spring也提供了一个MailSender的子接口, 名为org.springframework.mail.javamail.JavaMailSender，同时也提供了一个对JavaMail的MIME类型的消息分块的回调interface，名为org.springframework.mail.javamail.MimeMessagePreparator</para>
        <para>首先，修改mail.properties 文件</para>
        <programlisting><![CDATA[
mail.host=smtp.163.com
mail.password=xxxx
mail.username=xxxx]]>
        </programlisting>
        <para>一看就知道HOST，服务名，用户名和密码的设置</para>
        <para>第二，给applicationContext-mail.xml文件减肥</para>
        <programlisting><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN 2.0//EN" "http://www.springframework.org/dtd/spring-beans-2.0.dtd">
<beans default-autowire="byName" default-lazy-init="true">
    <!-- 使用Spring封装的Mail Sender -->
    <bean id="mailSender"
        class="org.springframework.mail.javamail.JavaMailSenderImpl">
        <property name="host" value="${mail.host}" />
        <property name="username" value="${mail.username}" />
        <property name="password" value="${mail.password}" />
        <property name="javaMailProperties">
            <props>
                <prop key="mail.smtp.auth">true</prop>
                <prop key="mail.smtp.timeout">25000</prop>
            </props>
        </property>
    </bean>
</beans>]]>
        </programlisting>
    </sect1>
    <sect1>
        <title>UTF-8与国际化。</title>
        <sect2>
            <title>i18N基础</title>
            <orderedlist>
                <listitem>
                    <para>编写messages.zh_CN.properties</para>
                    <para>用中文写完后，用java带的native2ascii.exe或者ant的native任务把它转成非人类的Unicode编码。</para>
                </listitem>
                <listitem>
                    <para>在纯Java API里，国际化是这样做的：</para>
                    <programlisting><![CDATA[
ResourceBundle rb = ResourceBundle.getBundle("messages");
String welcome = rb.getString("welcome");
String welcomeCalvin =   MessageFormat.format(welcome,new String[]{"calvin"});]]>
                    </programlisting>
                    <para>第一二句从classpath里找到messages_zh_CN.properties，读出"欢迎你，{0}"字样。</para>
                    <para>第三句把上文格式化成"欢迎你，family168"</para>
                </listitem>
                <listitem>
                    <para>在Servlet环境下，国际化是这样做的</para>
                    <para><![CDATA[则靠<fmt:message>tag]]></para>
                    <programlisting><![CDATA[
<%@ taglib uri="http://java.sun.com/jstl/fmt" prefix="fmt" %>
<fmt:message key="welcome"/>]]>
                    </programlisting>
                    <para>可以用context-param来定义默认的properties文件</para>
                    <programlisting><![CDATA[
<context-param>
    <param-name>javax.servlet.jsp.jstl.fmt.localizationContext</param-name>
    <param-value>messages</param-value>
</context-param>]]>
                    </programlisting>
                    <para><![CDATA[不过这样定义的缺点是只能定义一个文件，如果所有信息都集中在一个文件会好长，而如果有多个properties，就惟有在页面用<fmt:bundle>绑定了。]]></para>
                </listitem>
            </orderedlist>
        </sect2>
        <sect2>
            <title>Spring的messageSource增强</title>
            <para>一是ApplicationContext将充当一个单例的角色，不再需要每次使用i18时都初始化一次ResourceBundle</para>
            <para>二是可以代表多个Resource Bundle.</para>
            <para>在ApplicationContext的定义文件中，增加如下节点：</para>
            <programlisting><![CDATA[
<bean id="messageSource" class="org.springframework.context.support.ResourceBundleMessageSource">
    <property name="basename" value= "messages"/>
</bean>]]>
            </programlisting>
            <para>在pure Java中</para>
            <programlisting><![CDATA[
context.getMessage("welcome", null, LocaleContextHolder.getLocale())]]>
            </programlisting>
            <para><![CDATA[而经Spring MVC JSTL ViewResolver调用的JSP，<fmt:message>将继续发挥它的功效。]]></para>
            <para><![CDATA[不过这里挺麻烦的，第一如果不是从MVC JSTL转的，messageSource的定义就会失效。而如果定义了<context-param>，则messageSource的定义又会失效.......]]></para>
            <para><![CDATA[还有，<spring:message> 鸡肋一块，因为它如果找不到key对应的就会抛异常，好恐怖。]]></para>
            <para>还还有，spring还有有趣的theme机制，和i18n一样的原理，解决了"做成图片的文字"的国际化，让不同语言的美术字图片的路径分别定义在theme_zh_CN.properties和theme_en_US.properties里面。</para>
        </sect2>
    </sect1>
    <sect1>
        <title>异常处理</title>
        <sect2>
            <title>业务异常类</title>
            <para>所有业务异常类派生于BusinessException基类。</para>
            <para>原则上，要进行相同处理的异常分为一类，用ERROR_CODE标识不同。</para>
            <para>出错信息统一写在errors.properties，以ERROR_CODE为主键，支持i18N，由基类提供默认的getMessage()函数。</para>
        </sect2>
        <sect2>
            <title>Servlet规范里的异常控制</title>
            <sect3>
                <title>按error-code统一定义错误页面</title>
                <programlisting><![CDATA[
<error-page>
    <error-code>404</error-code>
    <location>/404.jsp</location>
</error-page>
<error-page>
    <error-code>500</error-code>
    <location>/error.jsp</location>
</error-page>]]>
                </programlisting>
            </sect3>
            <sect3>
                <title>按异常类型定义单独错误页面</title>
                <programlisting><![CDATA[
<error-page>
    <exception-type>org.sprngside.bookstore.UserNotFound</exception-type>
    <location>/userNotFound.jsp</location>
</error-page>]]>
                </programlisting>
            </sect3>
            <sect3>
                <title>在JSP里单独定义错误页面</title>
                <programlisting><![CDATA[
<@ errorPage="error.jsp">]]>
                </programlisting>
            </sect3>
            <sect3>
                <title>error.jsp的处理</title>
                <para>error.jsp会同时处理jsp,servlet,和spring抛过来的异常</para>
                <para>其中jsp的异常在exception 变量中.</para>
                <para>servlet的异常在(Exception)request.getAttribute("javax.servlet.error.exception")</para>
                <para>spring的异常在(Exception) request.getAttribute("exception")</para>
                <para>使用(String) request.getAttribute("javax.servlet.error.request_uri")获得 request_uri</para>
                <para>使用logger.error(exception.getMessage(), exception); 记录整个异常栈</para>
            </sect3>
        </sect2>
    </sect1>



    <sect1>
        <title>事务</title>
        <sect2>
            <title>本地事务与分布式事务</title>
            <itemizedlist>
                <listitem>
                    <para>本地事务</para>
                    <para>完全依赖于DB、JMS自身，如直接调用jdbc中的conn.commit();这里没应用服务器什么事，所以也不支持多数据源的全局事务。</para>
                </listitem>
                <listitem>
                    <para>分布式事务</para>
                    <para>在JavaEE世界的事务在JTA、JTS规范和XA Sources之上实现。</para>
                    <para>JTA是用户编程接口，JTS是服务器底层服务，两者一般由应用服务器自带实现，而atomikos、JOTM和JBoss Transaction是专门搞局抢生意的。</para>
                    <para>XA Sources其实先于JavaEE而存在，JDBC driver必须有javax.sql.XADataSource接口的实现类，否则所谓二阶段提交就是个伪能力。</para>
                    <para>JavaEE除了支持JDBC和JMS外，还引入了JCA模型。JCA可以说是目前唯一可移植的插入JavaEE事务的资源模型，因此像JDO这类框架/Server就是靠乖乖出自己的JCA连接器来参与JavaEE事务的。</para>
                </listitem>
            </itemizedlist>
        </sect2>
        <sect2>
            <title>编程式模型</title>
            <para>手工调用jdbc的connection事务方法和使用JTA接口都属于编程式开发，在EJB中叫BMT(Bean管理事务)。</para>
            <para>JTA最重要的接口就是UserTransaction和它的六个方法</para>
            <para>begin，commit，rollback，getStatus，setRollbackonly，setTransactionTimeout。</para>
            <para>程序需要UserTransaction时可以从JNDI领取，不过JNDI名随应用服务器不同而不同。EJB3里可以直接用个@Resource注入。</para>
        </sect2>
        <sect2>
            <title>宣告式模型</title>
            <para>前面都是铺垫，这个才是主打的事务模型，如EJB的CMT(容器管理事务)和Spring。</para>
            <para>其中EJB2.0，Spring1.0在部署描述符和applicationContext.xml中定义，而EJB3.0和Spring2.0则采用annotation。</para>
        </sect2>
        <sect2>
            <title>事务类型</title>
            <para>这里JavaEE与Spring的定义基本相同：</para>
            <itemizedlist>
                <listitem>
                    <para>Required：如果Context中有事务就加入，没有就自己创建一个。(最常用设置)</para>
                </listitem>
                <listitem>
                    <para>Mandatory：永远加入一个事务。如果当前Context没有事务，抛出异常。(那些不打算自己负责rollback事务的方法，必须加入到别人的事务，由别人来控制rollback)</para>
                </listitem>
                <listitem>
                    <para>RequiresNew：永远新建一个事务。(那些不管别人如何，自己必须提交事务的方法，比如审计信息是一定要写的)</para>
                </listitem>
                <listitem>
                    <para>Supports：如果有事务就加入，如果没有就算了。永远不会创建新事务。(一般用于只读方法，不会主动创建事务，但如果当前有事务就加入，以读到事务中未提交的数据)</para>
                </listitem>
                <listitem>
                    <para>NotSupported：永远不使用事务，如果当前有事务，挂起事务。(那些有可能抛异常但异常并不影响全局的方法)</para>
                </listitem>
                <listitem>
                    <para>Never：不能在有当前事务的情况下调用本方法。（生人勿近?)</para>
                </listitem>
            </itemizedlist>
            <para>可见，Required是默认的设置，Supports是只读方法的最佳选择。</para>
        </sect2>
        <sect2>
            <title>事务隔离级别</title>
            <itemizedlist>
                <listitem>
                    <para>ReadUncommited：本事务可以看到另一事务未提交的数据。脏读。</para>
                </listitem>
                <listitem>
                    <para>ReadCommited：本事务只可以看到另一事务已提交的数据。不可重复读。</para>
                </listitem>
                <listitem>
                    <para>RepeatableRead：可重复读。在一个事务内，第一次读到的数据，在本事务没有提交前，无论另一个事务如何提交数据，本事务读到的数据都是不变的。</para>
                </listitem>
                <listitem>
                    <para>Serializable：串行化，同时只有一个事务能读相同的数据。</para>
                </listitem>
            </itemizedlist>
            <para>级别越低越安全效率也越低。隔离级别需要相关资源支持，如重复读在Oracle里会降级为ReadCommited。Spring里默认的Default级别完全看数据源的脸色行事。</para>
        </sect2>
        <sect2>
            <title>关于Rollback</title>
            <para>EJB里，想rollback只能sessionContext.setRollbackOnly()或者抛出EJBException。(EJB3还可以annotation设置某些自定义Exception可以触发rollback)</para>
            <para>在Spring里，同样只会rollback unchecked exception(RuntimeExcption及子类)，而checked exception(Exception及子类)是不会rollback的，除非你特别声明。</para>
            <programlisting><![CDATA[
 @Transactional(readOnly = false, propagation = Propagation.REQUIRES_NEW,rollbackFor = {MyException1.class,MyException2.class})]]>
            </programlisting>
            <para>因此所有在service层方法中用throws定义的Exception，都必须在事务定义中进行rollback设定。(请勿善忘)</para>
            <para>所有在service层方法中被catch处理了的异常，又希望容器辅助rollback的话，必须重抛一个预定义的RuntimeException的子类。(请勿回望)</para>
        </sect2>
        <sect2>
            <title>关于Spring</title>
            <para>Spring不希望编程式事务管理。</para>
            <para>Spring也不希望使用EJB CMT，CMT依赖于EJB而无法用于POJO，依赖于JTA全局事务对单数据源场景造成了浪费，而且rollback机制比较麻烦（必须为EJBException或手工setRollbackOnly())。</para>
            <para>因此Spring通过AOP实现了对POJO的整套宣告式事务体系；对jdbc,hibernate,jpa,jms等local数据源和JTA实现了统一的事务管理机制，而且支持本地资源与JTA在配置文件级的切换，而且改进了rollback机制。</para>
            <itemizedlist>
                <listitem>
                    <para>一个本地事务管理器：</para>
                    <programlisting><![CDATA[
<bean id="transactionManager" class="org.springframework.orm.jpa.JpaTransactionManager">
    <property name="entityManagerFactory" ref="entityManagerFactory" />
 </bean>]]>
                    </programlisting>
                </listitem>
                <listitem>
                    <para>Spring就会把请求都转发到应用服务器的JTA对象上（注意此时数据源也需要改为用JNDI从应用服务器获取)。</para>
                    <programlisting><![CDATA[
<bean id="myTxManager" class="org.springframework.transaction.jta.JtaTransactionManager"/>]]>
                    </programlisting>
                </listitem>
                <listitem>
                    <para>应用服务器专有的类型的JTA事务管理器：</para>
                    <programlisting><![CDATA[
<bean id="myTxManager" class="org.springframework.transaction.jta.WebLogicJtaTransactionManager"/>]]>
                    </programlisting>
                </listitem>
            </itemizedlist>
            <para>如果不喜欢在配置文件里用AspectJ定义事务，可以使用Spring的@Transactional annotation在service层上进行标注。</para>
            <para>对于只读的方法，可以加入@Transactional (readOnly=true) 标注以提高性能。</para>
            <para>因为Spring默认只对RuntimeException进行rollback，所以：</para>
            <para>所有在service层方法中用throws定义的checkedException，都必须在@Transactional中定义rollbackclass。</para>
            <para>所有在service层方法中catch处理了的Exception，又希望Spring辅助rollback的话，必须重抛一个RunTimeException，SpringSide里预定义了一个统一的ServiceException。</para>
        </sect2>
    </sect1>

</chapter>





