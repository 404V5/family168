<?xml version="1.0" encoding="UTF-8"?>
<chapter xml:id="env">
    <title>环境</title>

    <sect1>
        <title>HSQLDB</title>
        <sect2>
            <title>概述</title>
            <para>选用HSQLDB(http://www.hsqldb.org/) 因为</para>
            <itemizedlist>
                <listitem>
                    <para>支持嵌套查询在内的绝大部分SQL标准</para>
                </listitem>
                <listitem>
                    <para>支持Indentity主键</para>
                </listitem>
                <listitem>
                    <para>支持分页：SELECT TOP 5 FROM .., SELECT LIMIT 0 10 FROM ...</para>
                </listitem>
                <listitem>
                    <para>体积小，速度快，无需用户安装的嵌入式数据库方便DEMO</para>
                </listitem>
                <listitem>
                    <para>数据库文件为直接的script文件便于管理，能够编码控制开停</para>
                </listitem>
            </itemizedlist>
        </sect2>
        <sect2>
            <title>三种使用模式</title>
            <sect3>
                <title>Server模式</title>
                <para>启动一个单独的服务器端，监听对应端口。</para>
                <programlisting><![CDATA[
"%JAVA_HOME%/bin/java" -classpath hsqldb.jar org.hsqldb.Server -database.0 user -dbname.0 user]]>
                </programlisting>
                <para>在server.properties中配置server.port=9002，客户端使用如下URL连接。</para>
                <programlisting><![CDATA[
jdbc:hsqldb:hsql://localhost:9002/user]]>
                </programlisting>
                <para>如有多个数据库，则继续写命令行参数-database.1,-dbname.1</para>
            </sect3>
            <sect3>
                <title>In-Process模式</title>
                <para>In-Process 进程内模式因为不用网络连接，可以获得更高的速度。而且不需要用户手工启动数据库。</para>
                <para>缺点是不可以用DB工具察看数据库的当前情况。</para>
                <para>In-Process的使用方式是不用起服务，直接用JDBC Driver连接URL：</para>
                <programlisting><![CDATA[
jdbc:hsqldb:mem:.]]>
                </programlisting>
                <para>也可以使用文件保存数据。</para>
                <programlisting><![CDATA[
jdbc:hsqldb:file:db]]>
                </programlisting>
            </sect3>
            <sect3>
                <title>内存中数据库</title>
                <para>该模式既会读取classpath下的script文件初始化数据库，初始化之后的操作都在内存中进行，不会更改原来的script，所以很适合用来演示。</para>
                <para>与内嵌模式相同，不需要启动服务器端就可以连接。</para>
                <programlisting><![CDATA[
jdbc:hsqldb:res:db]]>
                </programlisting>
            </sect3>
        </sect2>
        <sect2>
            <title>数据查询与管理工具</title>
            <para>HSQLDB自带的管理器是用swing写的，很丑，默认用户名sa，密码为空。</para>
            <para>也可以使用其他支持jdbc的客户端访问hsqldb。</para>
        </sect2>
        <sect2>
            <title>Server模式随WebApp一起启动</title>
            <para>写一个listener，在项目启动的时候启动一个hsqldb的服务器端，免去了每次手工操作的麻烦。</para>
        </sect2>
        <sect2>
            <title>数据文件与数据存盘</title>
            <para>HSQLDB的数据文件为一个文本的sql文件，非常方便直接操控。</para>
            <para>如果要数据库彻底存盘到script文件，执行sql命令ShutDown。这个shutdown可以像update语句一样使用Statement执行，如果没有使用shutdown命令直接关闭服务器端，缓存中的数据会来不及保存到文件中而丢失。</para>
        </sect2>
    </sect1>

    <sect1>
        <title>使用其他数据库</title>
        <sect2>
            <title>Derby</title>
            <para>Derby已在JDK6.0 中自带，成为嵌入式数据库的事实标准。</para>
            <para>Derby有嵌入式与独立Server两种模式，为了贴近日常的开发时Oracle/Mysql的独立模式，我们用了独立Server模式。</para>
            <para>启动derby命令内容如下：</para>
            <programlisting><![CDATA[
set CLASSPATH=lib\derby.jar;lib\derbynet.jar;
java org.apache.derby.drda.NetworkServerControl start]]>
            </programlisting>
        </sect2>
        <sect2>
            <title>MySQL与Oracle</title>
            <para>开发实际项目时，需要将Derby更换为实际数据库，Hibernate支持大部分的数据库，其中Java程序员选用MySQL和Oracle的最多。</para>
            <para>更换MySQL与Oracle 步骤如下：</para>
            <orderedlist>
                <listitem>
                    <para>修改pom.xml 中的JDBC Driver(在parent的pom.xml中已定义其版本号)</para>
                    <para>MySQL：</para>
                    <programlisting><![CDATA[
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
</dependency>]]>
                    </programlisting>
                    <para>Oracle：</para>
                    <programlisting><![CDATA[
<dependency>
    <groupId>com.oracle</groupId>
    <artifactId>ojdbc14</artifactId>
</dependency>]]>
                    </programlisting>
                </listitem>
                <listitem>
                    <para>修改src/main/resource/applicationContext.xml中的JDBC数据库连接</para>
                </listitem>
                <listitem>
                    <para>修改src/main/resource/applicationContext.xml中的Hibernate Dialect，换成MySQL5InnoDBDialect，Oracle9Dialect</para>
                </listitem>
                <listitem>
                    <para>在应用服务器的数据库连接池中配置数据源</para>
                </listitem>
                <listitem>
                    <para>修改entity的ID生成策略</para>
                </listitem>
            </orderedlist>
            <para>注意Oracle中一般会为每个主要的表创建一个Sequence，所以统一定义IdEntity基类的写法不适合Oracle的情况，可将基类改为接口。</para>
            <para>而关于Mysql与Oralce的优化是一个很大的课题，不在本文档内描述。</para>
        </sect2>
    </sect1>

    <sect1>
        <title>Ant编程指南</title>
        <para>ant是一个百宝箱，日常工作都可以使用它完成。但是因为太灵活了，主要的项目流程管理还是基于maven2的规范。像一个项目，如果没有规范最后一定会发展到无法收拾的地步。</para>
        <para>某种意义上，还是依靠ant-contrib提供的if和for为ant加强了编程能力。</para>
        <sect2>
            <title>变量</title>
            <para>Ant里的变量有个诡异的特性，一旦被赋值就不会改变，这个特性有时候帮助很大，有时候让人很苦恼，一定要注意。另一样要注意的是，Ant里的变量和其他语言的变量一样，存在有效范围。</para>
            <orderedlist>
                <listitem>
                    <para>由命令行赋值</para>
                    <programlisting><![CDATA[
ant -Dtomcat.home]]>
                    </programlisting>
                </listitem>
                <listitem>
                    <para>与用户交互输入，Input task</para>
                    <programlisting><![CDATA[
<input message="请选择一个Target "
    validargs="compile,jar,test"
    addproperty="my.input"/>]]>
                    </programlisting>
                </listitem>
                <listitem>
                    <para>从propertis文件读取并存盘，propertyfile task</para>
                    <programlisting><![CDATA[
<propertyfile file="my.properties">
    <entry key="my.home" default="."/>
</propertyfile>]]>
                    </programlisting>
                    <para>如果my.properties 不存在，生成my.properties文件，my.home=.。有一个特别有用的地方：有些properties文件的属性每个开发者都不同，不想放入svn，但又想初始化数值，可以用该命令。</para>
                    <programlisting><![CDATA[
<propertyfile file="my.properties">
    <entry key="my.home" value="....."/>
</propertyfile>]]>
                    </programlisting>
                    <para>重新写入配置文件。</para>
                </listitem>
            </orderedlist>
        </sect2>
        <sect2>
            <title>流程控制</title>
            <para>主要依靠ant-contrib提供的if和for节点。</para>
            <orderedlist>
                <listitem>
                    <para>if task</para>
                    <para>ant原来可以在target级进行if判断(unless,if属性)，但实在太不方便了。</para>
                </listitem>
                <listitem>
                    <para>Conditions</para>
                    <para>但Ant预先封装的一堆condition很是很方便的。这些condition完全从实际出发，包括文件是否存在，http://localhost:8080是否连通都可以作为条件，见Ant的参考手册。</para>
                </listitem>
                <listitem>
                    <para>For task</para>
                    <para>支持"a,b,c,d" 字符串数组循环与目录，Fileset循环。</para>
                </listitem>
                <listitem>
                    <para>Parallel task</para>
                    <para>Parallel非常有用，比如我想一边开tomcat，一边做别的，就需要使用它，否则就只有用spawn=true属性把tomcat放在后台运行。spawn有很多不好的地方，比如不能即时看到console信息，停止ant运行不能把tomcat关掉等。</para>
                    <para>Parallel相当于一个容器，放在里面的每个task都会被并行执行。如果想把某几个task顺序执行，用相当于()的Sequential task 包起来。</para>
                </listitem>
                <listitem>
                    <para>Waitfor task</para>
                    <para><![CDATA[暂停ant执行直到条件符合，比如<waitfor><http url=http://localhost:8080/></waitfor>就会等待tomcat启动后才会继续往下执行。]]></para>
                </listitem>
            </orderedlist>
        </sect2>
        <sect2>
            <title>代码封装</title>
            <para>ant 代码最基本的封装是</para>
            <orderedlist>
                <listitem>
                    <para>ant task：调用其他脚本的任务，可设定dir与是否继承本脚本的变量。</para>
                </listitem>
                <listitem>
                    <para>antcall task：调用本脚本内其他task，可设置参数。</para>
                </listitem>
                <listitem>
                    <para>import task ：就像其他语言的include一样，引入其他脚本内容到本脚本里。</para>
                </listitem>
            </orderedlist>
        </sect2>
        <sect2>
            <title>extend</title>
            <orderedlist>
                <listitem>
                    <para>AntFetch,  AntCallBack task</para>
                    <para>ant-contrib贡献，对应于Ant与AntCall。原版只能向被调用函数传递变量，函数执行后没办法return 值。antcallback的语法如下</para>
                    <programlisting><![CDATA[
<antcallback target="mytarget" return="myresult"/>]]>
                    </programlisting>
                </listitem>
                <listitem>
                    <para>Macrodef task</para>
                    <para><![CDATA[作为最小的封装单位，与以<target>封装，<antcall target="xxx">调用差不太远，细微之处自行体验了。个人比较喜欢用macrodef。]]></para>
                </listitem>
                <listitem>
                    <para>Java task与Exec task直接执行Java类或程序</para>
                    <para>注意执行目录的定义，另在Windows下如果要直接运行dos窗口中的命令，以下指令启动默认浏览器访问localhost：</para>
                    <programlisting><![CDATA[
<exec executable="cmd.exe">
  <arg line="/c start http://localhost:8080"/>
</exec>]]>
                    </programlisting>
                </listitem>
                <listitem>
                    <para>扩展Ant的Task</para>
                    <para>扩展ant task很简单，实现execute方法执行task，实现setter接口让ant框架执行属性注入。继承稍微有点麻烦的是多层嵌套属性的注入。详细请看http://ant.apache.org/manual/developlist.html</para>
                </listitem>
                <listitem>
                    <para>文件操作</para>
                    <para>replace与copy 时加入filter, 都可以进行字符串替换.</para>
                    <para>concat在文件末添加其他文件的内容。</para>
                </listitem>
            </orderedlist>
        </sect2>
        <sect2>
            <title>看点:</title>
            <orderedlist>
                <listitem>
                    <para>compile中的Java文件编译，ClassPath设置与复制其他后缀名的资源文件。</para>
                </listitem>
                <listitem>
                    <para>war中的war打包，manifest文件生成与 timestamp,buildnumber应用。</para>
                </listitem>
                <listitem>
                    <para>test中的unit test。</para>
                </listitem>
                <listitem>
                    <para>usage中的input让用户输入要执行的task, antcall执行。</para>
                </listitem>
                <listitem>
                    <para>macrodef简化IDE copy。</para>
                </listitem>
            </orderedlist>
        </sect2>
        <sect2>
            <title>Ant-Contrib</title>
            <para><![CDATA[Ant-Contrib(网站)的<If>和<For>Task 绝对是使用Ant编写脚本的最重要补充。]]></para>
            <programlisting><![CDATA[
<if>
    <os family="unix"/>
    <then>
        <property name="ext" value="sh"/>
    </then>
    <else>
        <property name="ext" value="bat"/>
    </else>
</if>]]>
            </programlisting>
            <para>以下一段循环plugins目录，执行Install脚本</para>
            <programlisting><![CDATA[
<for param="plugindir">
    <path>
        <dirset dir="plugins">
            <depth max="0"/>
        </dirset>
    </path>
    <sequential>
        <exec executable="@{plugindir}/install.${ext}" dir="@{plugindir}"/>
    </sequential>
</for>]]>
            </programlisting>
        </sect2>
        <sect2>
            <title>用Ant调Maven管理JAR</title>
            <programlisting><![CDATA[
<typedef resource="org/apache/maven/artifact/ant/antlib.xml" uri="urn:maven-artifact-ant">
    <classpath>
        <pathelement location="lib/maven-artifact-ant-2.0.2-dep.jar"/>
    </classpath>
</typedef>
<artifact:dependencies pathId="maven.classpath" filesetId="maven.fileset">
    <artifact:pom file="pom.xml"/>
</artifact:dependencies>

<copy todir="lib/">
    <fileset refid="maven.fileset"/>
    <mapper type="flatten"/>
</copy>]]>
            </programlisting>
            <para>第1句从maven-artifact-ant-2.0.2-dep.jar读antlib.xml，读出一堆maven的task。</para>
            <para>第2句分析pom.xml里的jar，如果没有就上http://repo1.maven.org/maven2 把jar下载到${user.home}/.m2/目录。并把所有jar定义成ant的fileset对象--maven.fileset。</para>
            <para>第3句把maven.fileset定义的，放在${user.home}/.m2/里的jar拷贝到项目lib目录。</para>
            <para>个人感觉比较鸡肋，不如考虑去试试ivy。</para>
        </sect2>
    </sect1>

    <sect1>
        <title>Maven构建管理实践</title>
        <sect2>
            <title>使用模式</title>
            <para>在持续集成时，推荐使用maven脚本来测试、打包和部署项目(详见Maven Plugins资料)。</para>
            <para>实际开发时，就算没有本地服务器，直接把.m2目录发过去也可以起到统一依赖库的效果，最后记得给eclipse配置一个M2_REPO的变量，svn中就不用放jar包了。</para>
            <para>实际中用maven2还有一个好处，就是新手不知道如何向pom.xml中添加依赖，不会自作主张的添加依赖，减少了依赖冲突的风险。</para>
            <para>尚未用过m2eclipse</para>
        </sect2>
        <sect2>
            <title>parent/pom.xml</title>
            <para>所有项目继承于parent/pom.xml 文件，集中定义了所有的仓库，插件，依赖Jar的公共属性。</para>
            <para>当有多个项目时，建议单独建立parent，不用在里边设置modules，这样可以避免每次修改parent都要牵连其他模块。</para>
        </sect2>
        <sect2>
            <title>目录结构</title>
            <para>目录结构基本采用maven的默认设置，唯有src/main/webapp里的目录层次太多了，而且又不能像java源文件那样在IDE里快捷的显示，因此将提升到/webapp。</para>
            <para>个人认为resouces目录和java目录还是分开的好，资源文件单独放置更容易管理。</para>
        </sect2>
        <sect2>
            <title>私服</title>
            <para>Nexus作为sonatype公司三宝之一，jar文件以文件系统形式存放，要优于Artifactory。</para>
            <para>建议每个采用Maven的团队都搭建一个自己的私服，详细的设置方法见Maven资料。</para>
        </sect2>
        <sect2>
            <title>m2Ecipse插件</title>
            <para>安装0.9.6以上版本，只需Maven Embedder、Maven Intergration for Eclipse、Maven POM Editor、Maven POM XML Editor、Maven Intergration for WTP 五个模块即可。</para>
            <para>m2eclipse可以import maven文件在eclipse项目中来创建整个wtp项目，比较方便，而且不会出现这样那样不合拍的奇怪事情。</para>
        </sect2>
        <sect2>
            <title>插件</title>
            <itemizedlist>
                <listitem>
                    <para>Tomcat plugin: 用于持续集成时将web项目部署到tomcat服务器，详见Maven Plugins资料。</para>
                </listitem>
                <listitem>
                    <para>SQL plugin:用于执行sql，详见/tools/derby/pom.xml。</para>
                </listitem>
                <listitem>
                    <para>Dependency:用于分析项目的依赖jar，详见Maven资料。</para>
                </listitem>
                <listitem>
                    <para>Archetype: 用于生成新项目，详见Maven Archetype。</para>
                </listitem>
            </itemizedlist>
        </sect2>
    </sect1>

    <sect1>
        <title>SVN</title>
        <sect2>
            <title>优点</title>
            <itemizedlist>
                <listitem>
                    <para>对空目录，无论要留要删，都比only base file的CVS好。</para>
                </listitem>
                <listitem>
                    <para>可以改名，对于喜欢重构的同志比较有用，rename后仍然可以方便的比较版本间异同，commit信息也方便保留。</para>
                </listitem>
                <listitem>
                    <para>把每次提交捆绑在一起，日后查记录时能看到同时提交的文件。对于一次提交一个issue相关文件的同学来讲，这是个很实用的功能。Web应用和桌面应用比，就是分层N多，一个改动总要改N个源码+配置文件，现在能绑在一起了挺不错。</para>
                </listitem>
                <listitem>
                    <para>http wav的路径清晰，发布项目的路径很容易，另外用简单的目录概念代替了复杂的分支与标签，而且使用映射，使得开分支作备份之类的不用把数据重新传一次，成本好低。</para>
                </listitem>
                <listitem>
                    <para>小海龟写提交注释时居然有文件名auto complete，二进制文件也是只update差异，不update全部等等。</para>
                </listitem>
            </itemizedlist>
            <para>不过海龟仅仅支持一部分的svn命令，比如move就要自己敲。</para>
        </sect2>
        <sect2>
            <title>在Ant中使用Subversion</title>
            <para>Ant暂时没有Subversion的Task，需自行下载JavaSVN项目，以命令行形式执行。</para>
            <programlisting><![CDATA[
<target name="svn-export" depends="init" description="导出洁净的SVN仓库">
    <delete dir="${release.exportdir}"/>
    <java classname="org.tmatesoft.svn.cli.SVN" dir="${basedir}" fork="true">
        <arg value="export"/>
        <arg value="."/>
        <arg value="${release.exportdir}"/>
        <classpath>
            <pathelement location="lib/javasvn-cli.jar"/>
            <pathelement location="lib/javasvn.jar"/>
        </classpath>
    </java>
</target>]]>
            </programlisting>
        </sect2>
    </sect1>

    <sect1>
        <title>Hudson持续集成</title>
        <para>Hudson比CI Server祖宗的CruiseControl来说，全图形化的管理界面而不是讨厌的XML配置文件，以及超快的发展速度都完胜了CC。</para>
        <para>Hudson可以通过简单的配置，在工作时间每四小时用Subversion下载一次源码，并用Maven进行编译，测试，打包和重新部署到演示服务器上。</para>
        <para>如果出现错误，会把问题发给项目经理以及这次编译间隙里所有有份提交代码的开发人员。</para>
        <para>详见持续集成资料，注意在用于持续集成的tomcat的conf/context.xml 中加入antiJARLocking="true" antiResourceLocking="true"配置已防止jar lock住undeploy不了。(但此参数只适合于持续集成的tomcat。)</para>
        <sect2>
            <title>启动</title>
            <para>既支持命令行方式调用，也支持以war包的形式发布到tomcat中。</para>
            <para>使用命令行的情况如下：</para>
            <programlisting><![CDATA[
nohup java -jar hudson.war --httpPort=9999 --ajp13Port=9001 &]]>
            </programlisting>
        </sect2>
        <sect2>
            <title>新建项目</title>
            <itemizedlist>
                <listitem>
                    <para>设置系统变量MAVEN_HOME。</para>
                </listitem>
                <listitem>
                    <para>Build a free-style software project 。</para>
                </listitem>
                <listitem>
                    <para>Discard Old Builds：选Days to keep builds，填10，build记录保留10天。</para>
                </listitem>
                <listitem>
                    <para>Source Code Management  选 Subversion 并填上URL。</para>
                </listitem>
                <listitem>
                    <para>Build Triggers 选Build periodically，填0 (8-22)/4 * * * (工作时间里，每4小时执行一次，详细可点击输入框旁的帮助按钮)</para>
                </listitem>
                <listitem>
                    <para>Builds选Invoke Top Level Maven Target，这里选test tomcat:undeploy war:exploded tomcat:exploded，还可以添加其他的ant,shell script命令。</para>
                </listitem>
                <listitem>
                    <para>E-mail Notification：Recipients 说明必须发送的email列表，如项目经理的mail。勾选：Send separate e-mails to individuals who broke the build，会发给每个build之间提交过代码的SVN帐号。SVN帐号的email地址在Peoples中配置。在整个Hudson的configure中配置SMTP信息及SVN帐号的默认email后缀（如默认后缀为@gmail.com，则xyz20003帐号的默认email为xyz20003@gmail.com）</para>
                </listitem>
                <listitem>
                    <para>Totally, Hudson会在工作时间每四小时用Subversion下载一次源码，并用Maven进行编译，测试，打包和重新部署到演示服务器上。如果出现错误，会把问题发给项目经理以及这次编译间隙里所有有份提交代码的开发人员。</para>
                </listitem>
                <listitem>
                    <para>注意在用于持续集成的tomcat的conf/context.xml 中加入antiJARLocking="true" antiResourceLocking="true"配置已防止jar lock住undeploy不了。(但此参数只适合于持续集成的tomcat。)</para>
                </listitem>
            </itemizedlist>
        </sect2>
        <sect2>
            <title>持续集成实践</title>
            <para>持续集成服务器既可以尽快发现问题并通知整个团队，也可以搭建演示服务器让需求人员、项目经理等非战斗人员可以随时观看项目。</para>
            <para>《Continuous.Integration -- Improving.Software.Quality》</para>
        </sect2>
    </sect1>

</chapter>

