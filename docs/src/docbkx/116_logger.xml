<?xml version="1.0" encoding="UTF-8"?>
<chapter xml:id="logger">
    <title>日志</title>
    <sect1>
        <title>log4j</title>
        <sect2>
            <title>Spring对log4j的几个增强</title>
            <note><para>个人建议都不要使用。</para></note>
            <itemizedlist>
                <listitem>
                    <para>定时刷新log4j.properties，无须重启服务器更新log4j设置。虽然这是个J2EE Best Practice，但在Spring的JavaDoc里注明了不推荐用于生产环境，因为服务器重启的时候，那条watch thread不会关闭。</para>
                </listitem>
                <listitem>
                    <para>将log4j.properties文件放在WEB-INF/log4j.properties。</para>
                    <para>这种增强看不出有什么好处，而且如果放WEB-INF，测试的时候就不能输出log4j信息了，除非像Appfuse那样把WEB-INF也设为class path，不过这种设法只适用于Ant脚本的情况。</para>
                </listitem>
                <listitem>
                    <para>通过设定{web.root}这样的系统变量，将log文件放到项目的WEB-INF目录中</para>
                    <programlisting><![CDATA[
log4j.appender.logfile.File=${oa.root}/WEB-INF/logs/oa.log]]>
                    </programlisting>
                    <para>这样做的好处是路径比较稳定，但如果是war式的部署，每次重新部署的时候就会把原来的log文件全部删掉，遇上jboss 这种不解压war包的应用服务器就更会出错，所以把log文件放WEB-INF/logs不是一个好的选择。</para>
                </listitem>
            </itemizedlist>
            <para>其实logfile路径的规则是，如果不是绝对路径，就以应用运行的目录作为相对路径的根目录。</para>
            <para>可以这样定义，一般就指向tomcat和很多应用服务器的logs目录：</para>
            <programlisting><![CDATA[
log4j.appender.logfile.File=../logs/oa.log]]>
            </programlisting>
        </sect2>
        <sect2>
            <title>默认写入操作员ID</title>
            <para>比如在一个ServletFilter里实现如下代码</para>
            <programlisting><![CDATA[
Customer customer = (Customer) session.getAttribute("customer");
MDC.put("userid", customer.getLoginid());]]>
            </programlisting>
            <para>则log4j会线程安全的把cusomer id写入MDC的userId变量中，而userID变量的使用见下。</para>
        </sect2>
        <sect2>
            <title>忽略某些类库框架的不必要的信息</title>
            <para>控制第三方框架类库的logging level，可以避免满屏都是不重要的info，把真正重要的信息掩盖了。</para>
            <programlisting><![CDATA[
# Changing the log level to DEBUG when debug
log4j.logger.org.springframework=WARN
# Changing the log level to DEBUG will display SQL Hibernate generated
log4j.logger.org.hibernate=WARN
log4j.logger.org.hibernate.SQL=ERROR]]>
            </programlisting>
        </sect2>
        <sect2>
            <title>把重要的业务日志异步批量写入数据库</title>
            <para>配置文件示例:</para>
            <programlisting><![CDATA[
log4j.logger.business=INFO,db
log4j.appender.db=org.apache.log4j.jdbc.JDBCAppender
log4j.appender.db.BufferSize=10
log4j.appender.db.URL=jdbc:hsqldb:res:/hsqldb/bookstore
log4j.appender.db.driver=org.hsqldb.jdbcDriver
log4j.appender.db.user=sa
log4j.appender.db.password=
log4j.appender.db.sql=INSERT INTO SS_LOG4J_LOG (PRIORITY,LOGDATE,CLASS,METHOD,MSG) VALUES('%p','%d{yyyy-MM-dd HH:mm:ss}','%C','%M','%m')
log4j.appender.db.layout=org.apache.log4j.PatternLayout]]>
            </programlisting>
            <para>log4j提供了简单灵活且不影响性能的机制, 将重要业务日志写入数据库，方便日后的查询：</para>
            <para>建立一个任意命名的日志记录表，在log4j.properties里设置连接参数，根据刚才建的表名列名，编写插入的语句。</para>
            <para>BufferSize=10 这样的参数可以让日志异步批量写入，不会影响系统性能。</para>
            <para>业务日志log最好不要用原来的package结构，而是在项目里协调一个独立的名字，如business。</para>
            <programlisting><![CDATA[
Log buzzLog = LogFactory.getLog("business");]]>
            </programlisting>
            <para>自己有几点考虑，既然实时修改日志级别是最佳实践，为什么不干脆把数据库配置作为系统配置的一部分保存进数据库呢？这样不但可以实时修改，还可以保证系统重启后依然获得上次修改后的配置。</para>
        </sect2>
    </sect1>
    <sect1>
        <title>slf4j + logback</title>
        <para>slf4j由log4j作者Ceki开发，逐步取代apahce commons logging。</para>
        <para>logback由log4j作者Ceki开发，逐步取代log4j。</para>
        <sect2>
            <title>优势</title>
            <para>十个转移到logback的理由</para>
            <para>slf4j支持参数化的logger.error("帐号ID：{}不存在", userId);告别了if(logger.isDebugEnable()) 时代。</para>
            <para>另外logback的整体性能比log4j也较佳，hibernate等项目已经采用了slf4j:</para>
            <para>"某些关键操作，比如判定是否记录一条日志语句的操作，其性能得到了显著的提高。这个操作在LOGBack中需要3纳秒，而在Log4J中则需要30纳秒。 LOGBack创建记录器（logger）的速度也更快：13毫秒，而在Log4J中需要23毫秒。更重要的是，它获取已存在的记录器只需94纳秒，而 Log4J需要2234纳秒，时间减少到了1/23。"</para>
        </sect2>
        <sect2>
            <title>slf4J与旧日志框架的关系</title>
            <orderedlist>
                <listitem>
                    <para>slf4j等于commons-logging，是各种日志实现的通用入口，会根据classpath中存在下面哪一个Jar来决定具体的日志实现库。</para>
                    <itemizedlist>
                        <listitem>
                            <para>logback-classic(默认的logback实现)</para>
                        </listitem>
                        <listitem>
                            <para>slf4j-jcl.jar(apache commons logging)</para>
                        </listitem>
                        <listitem>
                            <para>slf4j-logj12.jar(log4j 1.2.4)</para>
                        </listitem>
                        <listitem>
                            <para>slf4j-jdk14(java.util.logging)</para>
                        </listitem>
                    </itemizedlist>
                </listitem>
                <listitem>
                    <para>将所有使用旧式日志API的第三方类库或旧代码的日志调用转到slfj。</para>
                    <itemizedlist>
                        <listitem>
                            <para>jcl-over-slf4j.jar/jcl104-over-slf4j</para>
                            <para>apache commons logging 1.1.1/1.0.4，直接替换即可。</para>
                        </listitem>
                        <listitem>
                            <para>log4j-over-slf4j.jar</para>
                            <para>log4j，直接替换即可。</para>
                        </listitem>
                        <listitem>
                            <para>jul-to-slf4j</para>
                            <para>jdk logging，需要在程序开始时调用SLF4JBridgeHandler.install()来注册listener</para>
                            <para>参考JulOverSlf4jProcessor，可在applicationContext.xml中定义该bean来实现初始化。</para>
                        </listitem>
                    </itemizedlist>
                </listitem>
            </orderedlist>
            <para>注意原有的log4j.properites将失效，logback网站上提供转换器，支持从log4j.properties 转换到logback.xml 。</para>
        </sect2>
        <sect2>
            <title>logback.xml的功能与配置</title>
            <orderedlist>
                <listitem>
                    <para>定义变量</para>
                    <programlisting><![CDATA[
<substitutionProperty name="log.base" value="../logs/helloworld" />   ]]>
                    </programlisting>
                </listitem>
                <listitem>
                    <para>JMX管理，logback支持使用JMX随时重载logback.xml或者单独设置某个package的level。</para>
                    <programlisting><![CDATA[
<jmxConfigurator />]]>
                    </programlisting>
                </listitem>
                <listitem>
                    <para>Appender配置</para>
                    <para>Rolling每天生成一个日志文件，方便按日期翻查。日志文件会自动压缩，定义文件名pattern时加上.zip即可。</para>
                    <para>Encoding默认为平台的编码，建议Console Appender使用默认值。</para>
                    <para>Tomcat和Glassfish中，设定日志路径为../logs/xxxx.log 都能将日志放入应用服务器本身的logs目录。</para>
                    <programlisting><![CDATA[
<appender name="logfile" class="ch.qos.logback.core.rolling.RollingFileAppender">
    <Encoding>UTF-8</Encoding>
    <File>${log.base}.log</File>
    <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
        <FileNamePattern>${log.base}.%d{yyyy-MM-dd}.log.zip</FileNamePattern>
    </rollingPolicy>
    <layout class="ch.qos.logback.classic.PatternLayout">
        <pattern>%date [%thread] %-5level %logger{80} - %msg%n</pattern>
    </layout>
</appender>]]>
                    </programlisting>
                    <para>特别设置某个logger打印到特殊的log文件。注意，logger的appender默认是叠加的，如果没有设置additivity="false"，会同时打印到stdout,logfile和webservice-logfile中。</para>
                    <programlisting><![CDATA[
<logger name="org.apache.cxf.interceptor.LoggingOutInterceptor" additivity="false">
    <level value="INFO" />
    <appender-ref ref="webservice-logfile" />
</logger>]]>
                    </programlisting>
                </listitem>
            </orderedlist>
        </sect2>
        <sect2>
            <title>slf4j和logback的使用</title>
            <orderedlist>
                <listitem>
                    <para>如果日志的参数超过3个，需要写成</para>
                    <programlisting><![CDATA[
Object[] params = {newVal, below, above};
logger.debug("Value {} was inserted between {} and {}.", params);]]>
                    </programlisting>
                </listitem>
                <listitem>
                    <para>因为内部已优化，作者认为slf4j的logger不需要定义为static。</para>
                </listitem>
                <listitem>
                    <para>可设置缓存后批量写日志文件(但服务器如果重启，可能会丢失未写到磁盘的记录)</para>
                </listitem>
                <listitem>
                    <para>MDC，用Filter，将当前用户名等业务信息放入MDC中，在日志format定义中即可使用该变量。</para>
                </listitem>
                <listitem>
                    <para>JMS Appender用于告警, DB Appender用于业务日志等</para>
                </listitem>
            </orderedlist>
            <para>可以使用插件，如生成Log代码的Eclipse插件Log4E。</para>
        </sect2>
        <sect2>
            <title>选型</title>
            <para>使用log4j作者的新作logback+slf4j，因为可以参数化的语句，不用再为了丁点性能写什么 if( logger.isDebugenable()) ....另外logback的整体性能也较佳，Hibernate、Jetty等项目已经迁移到了slf4j。</para>
            <para>特别注意使用commons logging + log4j的第三方框架的日志操作会被拦截并转发到logback中，因此原有的log4j.properties文件将失效，真正配置文件为logback.xml。</para>
            <para>而原来使用java.util.logging的第三方框架(如CXF)，使用JulOverSlf4jProcessor进行拦截。</para>
            <para>logback.xml与log4j.xml很像，详细配置见日志的资料。</para>
            <para>tomcat和glassfish中，设定日志路径为../logs/xxxx.log 都能将日志放入应用服务器本身的logs目录。</para>
        </sect2>
    </sect1>

</chapter>

